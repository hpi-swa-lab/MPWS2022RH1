<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Causality Graph Text Interface</title>
    <style>
        /* Remove default bullets */
        ul, #myUL {
            list-style-type: none;
        }

        /* Remove margins and padding from the parent ul */
        #myUL {
            margin: 0;
            padding: 0;
        }

        /* Style the caret/arrow */
        .caret {
            cursor: pointer;
            user-select: none; /* Prevent text selection */
        }

        /* Create the caret/arrow with a unicode, and style it */
        .caret::before {
            content: "\25B6";
            color: black;
            display: inline-block;
            margin-right: 6px;
        }

        /* Rotate the caret/arrow icon when clicked on (using JavaScript) */
        .caret-down::before {
            transform: rotate(90deg);
        }

        /* Hide the nested list */
        .nested {
            display: none;
        }

        /* Show the nested list when the user clicks on the caret/arrow (with JavaScript) */
        .active {
            display: block;
        }
    </style>
</head>
<body>
    <script src="lib/causality_graph.js"></script>
    <script src="zip.min.js"></script>
    <script>
        let simulate_purge = Module.cwrap("simulate_purge", "number", ["number"]);
        let simulate_purges_batched = Module.cwrap("simulate_purges_batched", "number", ["number", "number", "number", "number", "number"])
        let show_reachability = Module.cwrap("show_reachability", "number", ["number"]);
        let init = Module.cwrap("init", "number", ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);


        let methodList = []
        let transitiveSubNodes = {}

        function simulatePurge(str) {
            let ptr  = allocateUTF8(str)
            let retPtr = simulate_purge(ptr)
            let res = UTF8ToString(retPtr)

            // dealloc memory
            Module._free(ptr);
            Module._free(retPtr);

            return res
        }

        function simulatePurgesBatched(strs) {
            /*
            let indicesSortedByLengthDescending = Array(strs.length)
            for(let i = 0; i < indicesSortedByLengthDescending.length; i++)
                indicesSortedByLengthDescending[i] = i
            indicesSortedByLengthDescending.sort((a, b) => strs[b].length - strs[a].length)

            let methodIncluded = Array(methodList.length)
            for(let i = 0; i < methodIncluded.length; i++)
                methodIncluded[i] = false
             */

            let subsetsArr = new Uint32Array(strs.length * 2)

            let totalCount = 0

            for(let i = 0; i < strs.length; i++) {
                const count = transitiveSubNodes[strs[i]].length
                totalCount += count
                subsetsArr[i * 2 + 1] = count
            }

            let midsPtr = Module._malloc(totalCount * 4)
            let midsPos = 0

            for(let i = 0; i < strs.length; i++)
            {
                let count = subsetsArr[i * 2 + 1]
                let subsetArr = new Uint32Array(count)
                let pos = 0

                for(const mid of transitiveSubNodes[strs[i]])
                {
                    subsetArr[pos] = mid + 1
                    pos++
                }

                subsetsArr[i*2] = midsPtr + midsPos
                Module.HEAPU32.set(subsetArr, (midsPtr + midsPos) / 4)
                midsPos += count * subsetArr.BYTES_PER_ELEMENT
            }

            let subsetsArrPtr = Module._malloc(subsetsArr.length * subsetsArr.BYTES_PER_ELEMENT)
            Module.HEAPU32.set(subsetsArr, subsetsArrPtr / 4)

            let resultsArrPtr = Module._malloc(strs.length * 4)

            let method_weights_ptr = Module._malloc((codesizes.length + 1) * 4)
            let method_weights_arr = Module.HEAP32.subarray(method_weights_ptr / 4, method_weights_ptr / 4 + codesizes.length + 1)

            method_weights_arr[0] = 0
            for(let i = 0; i < codesizes.length; i++)
                method_weights_arr[i+1] = codesizes[i]

            const status = simulate_purges_batched(subsetsArrPtr, strs.length, method_weights_ptr, method_weights_arr.length, resultsArrPtr)

            let res = Module.HEAPU32.subarray(resultsArrPtr / 4, resultsArrPtr / 4 + strs.length)

            Module._free(method_weights_ptr)
            Module._free(subsetsArrPtr)
            Module._free(midsPtr)
            // Module._free(resultsArrPtr)
            // TODO: Free resultsArrPtr

            return status == 0 ? null : res
        }

        function pressBtn(str) {
            document.getElementById("Output").value = simulatePurge(str)
            printReachability(document.getElementById("Input_reachability").value)
        }

        function printReachability(str){
            let ptr  = allocateUTF8(str)

            let retPtr = show_reachability(ptr)

            document.getElementById("Output_reachability").value = UTF8ToString(retPtr)

            // dealloc memory
            Module._free(ptr);
            Module._free(retPtr);
        }

        const model = (() => {

            return {
                getEntries(file, options) {
                    return (new zip.ZipReader(new zip.BlobReader(file))).getEntries(options);
                },
                async getURL(entry, options) {
                    return URL.createObjectURL(await entry.getData(new zip.BlobWriter(), options));
                }
            };

        })();

        function doSomething(){
            let fileInput = document.getElementById("file-input");
            fileInput.dispatchEvent(new MouseEvent("click"));
            fileInput.onchange = selectFile;
        }

        async function selectFile() {
            try {
                let fileInput = document.getElementById("file-input");
                let selectedFile = fileInput.files[0];
                await loadFiles(selectedFile, "utf-8");
            } catch (error) {
                alert(error);
            }
        }

        function getMethodCodesizeDictFromReachabilityJson(data) {
            let dict = {}

            for (const toplevel of data) {
                for (const package in toplevel.packages) {
                    for (const type in toplevel.packages[package].types) {
                        for (const method in toplevel.packages[package].types[type].methods) {
                            const fullyQualifiedName = package + "." + type + "." + method
                            const codesize = toplevel.packages[package].types[type].methods[method].size
                            dict[fullyQualifiedName] = codesize
                        }
                    }
                }
            }

            return dict
        }

        async function loadFiles(selectedFile, filenameEncoding) {
            let entries = await model.getEntries(selectedFile, { filenameEncoding });
            if (entries && entries.length) {
                filesAsByteArrays = {}

                methodList = (await entries.find(e => e.filename === "methods.txt").getData(new zip.TextWriter())).split('\n')
                methodList.pop()
                prepareListView(generateHierarchyFromList(methodList))

                let reachabilityData = JSON.parse(await entries.find(e => e.filename === "reachability.json").getData(new zip.TextWriter()))
                let codesizesDict = getMethodCodesizeDictFromReachabilityJson(reachabilityData)
                codesizes = new Array(methodList.length)

                for(let i = 0; i < methodList.length; i++) {
                    codesizes[i] = codesizesDict[methodList[i]] ?? 0
                }


                for (const entry of entries) {
                    if(entry.filename === "reachability.json")
                    {
                        continue;
                    }

                    const zipFileWriter = new zip.Uint8ArrayWriter()
                    const data = await entry.getData(zipFileWriter)

                    let input_ptr = Module._malloc(data.length);
                    Module.HEAPU8.set(data, input_ptr);

                    filesAsByteArrays[entry.filename] = { data: input_ptr, length: data.length }
                }

                init(filesAsByteArrays["types.txt"].data, filesAsByteArrays["types.txt"].length,
                    filesAsByteArrays["methods.txt"].data, filesAsByteArrays["methods.txt"].length,
                    filesAsByteArrays["typeflows.txt"].data, filesAsByteArrays["typeflows.txt"].length,
                    filesAsByteArrays["typestates.bin"].data, filesAsByteArrays["typestates.bin"].length,
                    filesAsByteArrays["interflows.bin"].data, filesAsByteArrays["interflows.bin"].length,
                    filesAsByteArrays["direct_invokes.bin"].data, filesAsByteArrays["direct_invokes.bin"].length,
                    filesAsByteArrays["typeflow_methods.bin"].data, filesAsByteArrays["typeflow_methods.bin"].length,
                    filesAsByteArrays["typeflow_filters.bin"].data, filesAsByteArrays["typeflow_filters.bin"].length,
                    filesAsByteArrays["declaring_types.bin"].data, filesAsByteArrays["declaring_types.bin"].length,
                )

                for (const span of Object.values(filesAsByteArrays))
                {
                    Module._free(span.ptr)
                }
            }
        }
    </script>

    <button title="upload" onClick="doSomething()">Upload CausalityExport</button>

    <details>

        <br/>
        <label for="Input"></label><textarea id="Input" cols="100" rows="5" spellcheck="false" oninput="pressBtn(this.value)"></textarea>
        <label for="Input_reachability"></label><textarea id="Input_reachability" cols="100" rows="5" spellcheck="false" oninput="printReachability(this.value)"></textarea>
        <br/>
        <label for="Output"></label><textarea id="Output" cols="100" spellcheck="false" rows="20" readonly="readonly"></textarea>
        <label for="Output_reachability"></label><textarea id="Output_reachability" cols="100" spellcheck="false" rows="20" readonly="readonly"></textarea>
    </details>

    <input type="file" id="file-input" accept="application/zip" hidden>

    <input type="checkbox">Show generated code</input>

    <ul id="myUL">
        <li id="myLI">
            <span class="caret" id="myRoot">root</span>
        </li>
    </ul>

    <script>
        function generateHierarchyFromList(list) {
            const re = /[^\s(.)\[\]\$]+(?=\.|$|\[|\s|\$)|[^\s(.)]+\([^)]*\)|\[[^\]]+\]|\[\]$/g
            root = {}

            transitiveSubNodes = {}

            for(let mid = 0; mid < list.length; mid++) {
                const e = list[mid]

                let m = [...e.matchAll(re)]

                const parts = m.map(match => match[0])
                const partFullNames = m.map(match => e.substring(0, match.index + match[0].length))
                let parent = root

                for (let i = 0; i < parts.length; i++) {
                    if(!transitiveSubNodes[partFullNames[i]])
                        transitiveSubNodes[partFullNames[i]] = []
                    transitiveSubNodes[partFullNames[i]].push(mid)

                    let part = parts[i]

                    if(!parent.children)
                        parent.children = {}
                    if(!parent.children[part]) {
                        parent.children[part] = { fullname: partFullNames[i] }
                    }
                    parent = parent.children[part]
                }

                let last_part = parts[parts.length - 1]
                parent[last_part] = null
            }

            return root
        }

        function expandClickHandler(element, node) {
            let expanded = element.classList.toggle("caret-down");

            if(!element.parentElement.querySelector(".nested")) {
                if (expanded) {
                    element.parentElement.appendChild(generateHTML(node))

                    strs = []

                    for (e of element.parentElement.querySelector("ul").children) {
                        let node_prefix = e.getAttribute("data-node-name")
                        strs.push(node_prefix)
                    }

                    res = simulatePurgesBatched(strs)

                    let list = element.parentElement.querySelector('ul')

                    let i = 0
                    for (e of list.children) {
                        let cutoff_size = res[i]
                        let str = ""
                        if(cutoff_size > 1000000)
                            str = (cutoff_size / 1000000).toPrecision(3) + " MB"
                        else if(cutoff_size > 1000)
                            str = (cutoff_size / 1000).toPrecision(3) + " KB"
                        else
                            str = cutoff_size.toPrecision(3) + " B"

                        e.querySelector("#purged").textContent = str
                        i++
                    }

                    let order = new Array(list.children.length)
                    for(let i = 0; i < order.length; i++)
                        order[i] = i

                    let nodes = list.children
                    order.sort((a, b) => res[b] - res[a]).map(i => nodes[i]).forEach(node => list.appendChild(node))
                }
            }

            element.parentElement.querySelector(".nested").classList.toggle("active");
        }

        function generateHTML(data) {
            let ul = document.createElement("ul")
            ul.className = "nested"

            for(d in data.children) {
                let li = document.createElement("li")
                ul.appendChild(li)
                let span = document.createElement("span")
                li.appendChild(span)
                span.appendChild(document.createTextNode(d))
                span.setAttribute("title", data.children[d].fullname)
                li.setAttribute("data-node-name", data.children[d].fullname)
                let out = document.createElement("span")
                out.style = "margin-left: 25px; color: #808080"
                li.appendChild(out)
                out.id = "purged"
                /*
                let checkbox = document.createElement("input")
                checkbox.setAttribute("type", "checkbox")
                checkbox.setAttribute("data-node-name", prefix + d)
                li.appendChild(checkbox)
                */

                if(data.children[d].children) {
                    let node = data.children[d]
                    span.className = "caret"
                    span.addEventListener("click", () => {
                        expandClickHandler(span, node);
                    });
                }
            }

            return ul
        }

        function prepareListView(data) {
            const rootTreeViewElement = document.getElementById("myRoot")
            rootTreeViewElement.addEventListener("click", () => {
                expandClickHandler(rootTreeViewElement, data)
            })
        }
    </script>
</body>
</html>

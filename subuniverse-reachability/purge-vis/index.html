<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Causality Graph Text Interface</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <script src="lib/causality_graph.js"></script>
    <script src="zip.min.js"></script>
    <script>
        let simulate_purge = Module.cwrap("simulate_purge", "number", ["number", "number"]);
        let simulate_purges_batched = Module.cwrap("simulate_purges_batched", "number", ["number", "number"])
        let show_reachability = Module.cwrap("show_reachability", "number", ["number"]);
        let init = Module.cwrap("init", "number", ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
        let get_reachability_hyperpath = Module.cwrap("get_reachability_hyperpath", "number", ["number"])


        let methodList
        let typeList
        let all_reachable_ptr

        function simulatePurge(purge_group) {
            let midsPtr = Module._malloc(purge_group.length * 4)
            let midsArray = Module.HEAPU32.subarray(midsPtr / 4, midsPtr / 4 + purge_group.length)

            for (let i = 0; i < purge_group.length; i++)
                midsArray[i] = purge_group[i] + 1

            let method_history_ptr = simulate_purge(midsPtr, purge_group.length)
            // dealloc memory
            Module._free(midsPtr);

            return Module.HEAPU8.slice(method_history_ptr, method_history_ptr + codesizes.length)
        }

        function calcPurgeNodesCount(purge_root) {
            let cnt = 1
            if(purge_root.mids && purge_root.children)
                cnt++
            if(purge_root.children)
                for(const child of purge_root.children)
                    cnt += calcPurgeNodesCount(child)
            return cnt
        }

        function calcMidsCount(purge_root) {
            let cnt = 0
            if(purge_root.mids)
                cnt += purge_root.mids.length
            if(purge_root.children)
                for(const child of purge_root.children)
                    cnt += calcMidsCount(child)
            return cnt
        }

        function simulatePurgesBatched(purge_root, resultCallback, prepurgeMids = []) {
            const prepurgeMidsSet = new Set(prepurgeMids)

            const overlap = purge_root.children.flatMap(c => c.mids).some(mid => prepurgeMidsSet.has(mid))


            let purgeNodesCount = calcPurgeNodesCount(purge_root)

            let subsetsArrLen = (purgeNodesCount) * 4 /* {{ptr, len}, {child_ptr, child_len}} */
            let subsetsArrPtr = Module._malloc(subsetsArrLen * 4 /* (4 byte ptr/len) */)
            let subsetsArr = Module.HEAPU32.subarray(subsetsArrPtr / 4, subsetsArrPtr / 4 + subsetsArrLen)

            let midsCount = calcMidsCount(purge_root) + prepurgeMids.length

            let midsPtr = Module._malloc(midsCount * 4)
            let midsPos = midsPtr / 4

            let indexToInputNode = Array(purgeNodesCount)
            {
                let i = 1

                function layoutChildren(purge_root, offset) {
                    indexToInputNode[offset] = purge_root
                    const midsPos_start = midsPos

                    const i_start = i

                    if (purge_root.mids) {
                        if (purge_root.children) {
                            subsetsArr[i*4] /* ptr */ = midsPos * 4
                            subsetsArr[i*4 + 1] /* len */ = purge_root.mids.length
                            subsetsArr[i*4 + 2] = 0 // no children
                            subsetsArr[i*4 + 3] = 0 // no children
                            i++
                        }
                        for(const mid of purge_root.mids)
                            Module.HEAPU32[midsPos++] = mid + 1
                    }

                    let i_end = i

                    if (purge_root.children) {
                        let local_i = i
                        i += purge_root.children.length
                        i_end = i
                        for (const child of purge_root.children) {
                            layoutChildren(child, local_i)
                            local_i++
                        }
                    }

                    const midsPos_end = midsPos

                    const slice = subsetsArr.subarray(offset*4, (offset+1)*4)
                    slice[0] = midsPos_start * 4
                    slice[1] = midsPos_end - midsPos_start
                    slice[2] = subsetsArrPtr + i_start * 16
                    slice[3] = i_end - i_start
                }

                for (const mid of prepurgeMids)
                    Module.HEAPU32[midsPos++] = mid + 1
                layoutChildren(purge_root, 0)
                // Also include prepurgeMids
                subsetsArr[0] = midsPtr
                subsetsArr[1] += prepurgeMids.length
            }
            assert(midsPos * 4 === midsPtr + midsCount * 4)

            const callback = (iteration, method_history_ptr) => {
                const inputNode = indexToInputNode[iteration]
                if (!inputNode)
                    return;
                const still_reachable = Module.HEAPU8.subarray(method_history_ptr, method_history_ptr + codesizes.length)
                resultCallback(inputNode, still_reachable)
                return 0
            }

            const callback_ptr = addFunction(callback, 'iii')
            const status = simulate_purges_batched(subsetsArrPtr, callback_ptr)
            removeFunction(callback_ptr)

            Module._free(subsetsArrPtr)
            Module._free(midsPtr)

            if(status === 0)
                throw new Error("simulate_purges_batched exited with error code " + status)
        }

        function printReachability(str){
            let ptr  = allocateUTF8(str)

            let retPtr = show_reachability(ptr)

            document.getElementById("Output_reachability").value = UTF8ToString(retPtr)

            // dealloc memory
            Module._free(ptr);
            Module._free(retPtr);
        }

        function getReachabilityHyperpath(mid) {
            const edgeBufPtr = get_reachability_hyperpath(mid+1)
            const edgeBufU32index = edgeBufPtr / Module.HEAPU32.BYTES_PER_ELEMENT
            const len = Module.HEAPU32.at(edgeBufU32index)
            const arr = Module.HEAPU32.subarray(edgeBufU32index + 1, edgeBufU32index + 1 + 3 * len)

            let edges = Array(len)

            for(let i = 0; i < edges.length; i++)
            {
                edges[i] = { src: arr[i*3] - 1, dst: arr[i*3+1] - 1 }
                const type = arr[i*3+2]
                if(type !== 0xFFFFFFFF)
                    edges[i].via_type = type
            }

            Module._free(edgeBufPtr)

            return edges
        }

        const model = (() => {

            return {
                getEntries(file, options) {
                    return (new zip.ZipReader(new zip.BlobReader(file))).getEntries(options);
                },
                async getURL(entry, options) {
                    return URL.createObjectURL(await entry.getData(new zip.BlobWriter(), options));
                }
            };

        })();

        function triggerFileSectionDialog() {
            let fileInput = document.getElementById("file-input");
            fileInput.dispatchEvent(new MouseEvent("click"));
            fileInput.onchange = selectFile;
        }

        function selectFile() {
            const fileInput = document.getElementById("file-input");
            if (fileInput.files.length > 0) {
                tryLoadFile(fileInput.files[0])
            }
        }

        async function tryLoadFile(file) {
            try {
                document.getElementById("fileselect-panel").hidden = true
                document.getElementById("loading-panel").hidden = false
                await loadFiles(file, "utf-8");
                document.getElementById("loading-panel").hidden = true
                document.getElementById("main-panel").hidden = false
            } catch (error) {
                alert(error);
                document.getElementById("loading-panel").hidden = true
                document.getElementById("fileselect-panel").hidden = false
                return
            }

            prepareListView(this.dataRoot)
        }

        function getMethodCodesizeDictFromReachabilityJson(data) {
            let dict = {}

            for (const toplevel of data) {
                for (const packageName in toplevel.packages) {
                    const package = toplevel.packages[packageName]
                    for (const typeName in package.types) {
                        const type = package.types[typeName]
                        for (const methodName in type.methods) {
                            const method = type.methods[methodName]
                            const fullyQualifiedName = `${packageName}.${typeName}.${methodName}`
                            dict[fullyQualifiedName] = method.size
                        }
                    }
                }
            }

            return dict
        }

        class ModuleHeapZipWriter extends zip.Uint8ArrayWriter {
            init(e = 0) {
                super.init()
                this.offset = 0
                this.arrayPtr = Module._malloc(e)
                this.arrayLen = e
            }

            writeUint8Array(e) {
                const t = this;
                if (t.offset + e.length > t.arrayLen) {
                    const n = t.arrayPtr;
                    const oldLen = t.arrayLen
                    t.arrayLen += e.length
                    t.arrayPtr = Module._malloc(t.arrayLen)
                    const newArray = Module.HEAPU8.subarray(t.arrayPtr, t.arrayPtr + t.arrayLen)
                    newArray.set(Module.HEAPU8.subarray(n, t.offset))
                    Module._free(n)
                }
                Module.HEAPU8.subarray(t.arrayPtr + t.offset, t.arrayPtr + t.arrayLen).set(e)
                t.offset += e.length
            }

            getData() {
                return { data: this.arrayPtr, length: this.offset}
            }
        }

        async function loadFiles(selectedFile, filenameEncoding) {
            let entries = await model.getEntries(selectedFile, { filenameEncoding });
            if (entries && entries.length) {

                let reachabilityData = JSON.parse(await entries.find(e => e.filename === "reachability.json").getData(new zip.TextWriter()))
                let methods = await entries.find(e => e.filename === "methods.txt").getData(new zip.TextWriter())
                methodList = methods.split('\n')
                if(methodList[methodList.length-1].length === 0) {
                    methodList.pop()
                }
                let types = await entries.find(e => e.filename === "types.txt").getData(new zip.TextWriter())
                typeList = types.split('\n')
                if(typeList[typeList.length-1].length === 0)
                    typeList.pop()

                let codesizesDict = getMethodCodesizeDictFromReachabilityJson(reachabilityData)
                codesizes = new Array(methodList.length)

                for(let i = 0; i < methodList.length; i++) {
                    codesizes[i] = codesizesDict[methodList[i]] ?? 0
                }

                const parameterFiles = ["typestates.bin", "interflows.bin", "direct_invokes.bin", "typeflow_methods.bin", "typeflow_filters.bin"]

                filesAsByteArrays = {}
                for (const entry of entries) {
                    if(parameterFiles.some(name => name === entry.filename))
                    {
                        const zipFileWriter = new ModuleHeapZipWriter()
                        filesAsByteArrays[entry.filename] = await entry.getData(zipFileWriter)
                    }
                }

                all_reachable_ptr = init(typeList.length,
                    methodList.length,
                    ...parameterFiles.flatMap(name => [filesAsByteArrays[name].data, filesAsByteArrays[name].length])
                )

                for (const span of Object.values(filesAsByteArrays))
                    Module._free(span.data)

                reachable_under_selection = Module.HEAPU8.slice(all_reachable_ptr, all_reachable_ptr + codesizes.length)
                reachable_in_image_view = reachable_under_selection
                this.dataRoot = generateHierarchyFromReachabilityJsonAndMethodList(reachabilityData, methodList)
            }
        }

        function allowDrop(ev) {
            ev.preventDefault();
        }

        function drop(ev) {
            if (ev.dataTransfer.files.length > 0) {
                ev.preventDefault()
                tryLoadFile(ev.dataTransfer.files[0])
            }
        }

        let precomputeCutoffs = true

        function changePrecomputeCutoffs(enable) {
            precomputeCutoffs = enable
        }
    </script>

    <div id="fileselect-panel" class="fullscreen" ondragover="allowDrop(event)" ondrop="drop(event)">
        <input type="file" id="file-input" accept="application/zip" hidden>
        <div class="center">
            <big>Drop <button onClick="triggerFileSectionDialog()"><big>or select</big></button> Causality Export</big>
        </div>
    </div>

    <div id="loading-panel" class="fullscreen" hidden>
        <div class="center">
            <big>Causality Graph is being parsed...</big>
        </div>
    </div>

    <div id="main-panel" class="fullscreen" hidden>
        <div class="overview-div">
            <span><b>Cut Overview:</b></span>
            <label>
                <input type="checkbox" checked="checked" onchange="changePrecomputeCutoffs(this.checked)">
                Precompute cutoffs
            </label>
            <div id="cut-overview-root"></div>
        </div>
        <div class="imageview-div">
            <span><b>In-Image Overview:</b></span>
            <div id="imageview-root"></div>
        </div>
        <div class="detail-div">
            <svg id="detail-svg" width="100%" height="100%">
                <marker id="arrowhead" markerWidth="10" markerHeight="7"
                        refX="10" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" />
                </marker>

                <g id="chartpanel">
                    <rect id="zoom-opfer" fill="black" opacity="0" height="100%" width="100%"></rect>
                    <g id="chart"></g>
                </g>
            </svg>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-dag@0.8.2"></script>

    <script>
        class Trie {
            constructor(dict) {
                this.root = { next: {} }
                for (const str in dict) {
                    let node = this.root
                    for (const c of str) {
                        if (!node.next[c]) {
                            node.next[c] = { next: {} }
                        }
                        node = node.next[c]
                    }
                    node.val = dict[str]
                }
            }

            find(str) {
                let node = this.root
                let val = undefined
                for (const c of str) {
                    if (!node.next[c])
                        return val
                    node = node.next[c]
                    if (node.val)
                        val = node.val
                }
                return val
            }
        }
    </script>
    <script>
        let selectedForPurging = new Set()

        function generateHierarchyFromReachabilityJsonAndMethodList(json, cgNodes) {
            let dict = { children: [] }

            prefixToNode = {}

            for (const toplevel of json) {
                let l1name = "ϵ"
                let l1fullname = ""

                let display_path = toplevel.path
                if (display_path && display_path.endsWith(".jar")) {
                    let index = display_path.lastIndexOf("/")
                    if (index !== -1) {
                        display_path = display_path.substring(index+1)
                    }
                }

                if (toplevel.path && toplevel.module) {
                    l1name = display_path + ":" + toplevel.module
                    l1fullname = toplevel.path + ":" + toplevel.module
                } else if(toplevel.path) {
                    l1name = display_path
                    l1fullname = toplevel.path
                } else if(toplevel.module) {
                    l1name = toplevel.module
                    l1fullname = toplevel.module
                }

                let l1 = { children: [], name: l1name, fullname: l1fullname, cg_nodes: [] }
                if (toplevel.path) {
                    prefixToNode[toplevel.path] = l1
                }
                dict.children.push(l1)

                for (const packageName in toplevel.packages) {
                    const package = toplevel.packages[packageName]
                    let prefix = ""
                    let l2 = l1

                    if(packageName.length !== 0) {
                        for (const subPackageName of packageName.split('.')) {
                            prefix += subPackageName + "."
                            let next = l2.children.find(n => n.name === subPackageName)
                            if(!next) {
                                next = { children: [], fullname: prefix, name: subPackageName, cg_nodes: [] }

                                /* Eigentlich sollten keine Causality-Graph-Knoten direkt in einem Package hängen.
                                 * Es gibt jedoch Knoten für Klassen, die nicht reachable sind (z.B. Build-Time-Features).
                                 * Diese müssen unbedingt in die Abschneide-Berechnung miteinbezogen werden.
                                 * Idealerweise sollten sie auch in der Baumstruktur auftauchen.
                                 * Das ist aber gerade noch zu kompliziert umzusetzen... */
                                prefixToNode[prefix] = next

                                l2.children.push(next)
                            }
                            l2 = next
                        }
                    }

                    for (const typeName in package.types) {
                        const type = package.types[typeName]
                        let l3 = { children: [], fullname: prefix + typeName, name: typeName, cg_nodes: [] }
                        prefixToNode[l3.fullname] = l3
                        l2.children.push(l3)

                        for (const method in type.methods) {
                            let l4 = { fullname: l3.fullname + "." + method, name: method, cg_nodes: [] }
                            prefixToNode[l4.fullname] = l4
                            l3.children.push(l4)
                        }
                    }
                }
            }

            const trie = new Trie(prefixToNode)

            for (let i = 0; i < cgNodes.length; i++) {
                const cgNodeName = cgNodes[i]
                const node = trie.find(cgNodeName)
                if (node)
                    node.cg_nodes.push(i)
            }

            return dict
        }

        function formatByteSizesWithUnitPrefix(size) {
            if(size > 1000000)
                return (size / 1000000).toPrecision(3) + " MB"
            else if(size > 1000)
                return (size / 1000).toPrecision(3) + " KB"
            else
                return size.toPrecision(3) + " B"
        }

        function forEachInSubtree(node, callback) {
            let stack = []
            stack.push(node)
            while (stack.length > 0) {
                const u = stack.pop()
                if (u.children)
                    stack = stack.concat(u.children)
                callback(u)
            }
        }

        function collectCgNodesInSubtree(node) {
            let group = []
            forEachInSubtree(node, u => {
                if (u.cg_nodes)
                    group = group.concat(u.cg_nodes)
            })
            return group
        }

        function insertChildren(element, node) {
            let list = generateHTML(node)
            element.appendChild(list)
            recalculateCutOverviewForSubtree(list, node)
        }

        function expandClickHandler(element, node, populateCallback) {
            let expanded = element.classList.toggle("caret-down");

            if(!element.parentElement.querySelector(".nested") && expanded) {
                populateCallback()
            }

            element.parentElement.querySelector(".nested").classList.toggle("active");
        }

        function generateHTML(data) {
            let ul = document.createElement("ul")
            ul.className = "nested"

            for(const d of data.children) {
                let li = document.createElement("li")
                li.className = "cut-row"
                d.html = li
                ul.appendChild(li)

                let cutSizeColumn = document.createElement("span")
                cutSizeColumn.className = "cut-size-column"
                li.appendChild(cutSizeColumn)

                let cutSizeBar = document.createElement("div")
                cutSizeBar.className = "cut-size-bar"
                li.appendChild(cutSizeBar)

                let node = d
                let span = document.createElement("span")
                span.className = "caret"
                if (d.children) {
                    span.addEventListener("click", () => {
                        expandClickHandler(span, node, () => insertChildren(li, node));
                    });
                } else {
                    span.style.visibility = "hidden"
                }
                li.appendChild(span)

                let nameSpan = document.createElement("span")
                nameSpan.appendChild(document.createTextNode(d.name))
                //nameSpan.title = d.fullname
                nameSpan.className = "node-text"
                li.appendChild(nameSpan)

                nameSpan.addEventListener("mouseenter", async () => {
                    if(selectedForPurging.has(node))
                        return;

                    const maybe_reachable_in_image_view = selectedForPurging.size === 0 ? node.reachable_after_cutting_this : node.reachable_after_additionally_cutting_this
                    if (maybe_reachable_in_image_view) {
                        reachable_in_image_view = maybe_reachable_in_image_view.arr
                        updatePurgeValues()
                        nameSpan.classList.add("hovered-for-purge")
                    }
                })

                nameSpan.addEventListener("mouseleave", async () => {
                    nameSpan.classList.remove("hovered-for-purge")

                    if(selectedForPurging.has(node))
                        return;

                    if(reachable_in_image_view !== reachable_under_selection) {
                        reachable_in_image_view = reachable_under_selection
                        updatePurgeValues()
                    }
                })

                nameSpan.addEventListener("click", async () =>  {
                    nameSpan.classList.remove("hovered-for-purge")
                    let selected = nameSpan.classList.toggle("selected-for-purge")
                    if (selected) {
                        selectedForPurging.add(node)
                    } else {
                        selectedForPurging.delete(node)
                    }

                    if (selected && node.reachable_after_additionally_cutting_this && /* When details are shown, we need simulatePurge anyway for path data */ !detailMid) {
                        reachable_in_image_view = reachable_under_selection = node.reachable_after_additionally_cutting_this.arr
                    } else {
                        reachable_in_image_view = reachable_under_selection = simulatePurge([...new Set([...selectedForPurging].flatMap(collectCgNodesInSubtree))])
                    }

                    updatePurgeValues()

                    await new Promise(resolve => setTimeout(resolve, 0))

                    if (detailMid) {
                        const edges = getReachabilityHyperpath(detailMid)
                        try {
                            renderGraphOnDetailView(edges, detailMid)
                        } catch {
                            // Ignore
                        }
                    }

                    await new Promise(resolve => setTimeout(resolve, 0))

                    if(precomputeCutoffs) {
                        precomputeCutOverview()
                    } else {
                        forEachInSubtree(this.dataRoot, u => {
                            delete u.reachable_after_additionally_cutting_this
                        })
                    }
                })
            }

            return ul
        }

        let maxCodeSize
        let detailMid

        function generateHtmlImageview(data) {
            let ul = document.createElement("ul")
            ul.className = "nested"

            for (const d of data.children) {
                let codesize = 0
                forEachInSubtree(d, (v) => {
                    if (v.cg_nodes)
                        for (const i of v.cg_nodes)
                            codesize += codesizes[i]
                })
                d.size = codesize
            }

            if (data === this.dataRoot) {
                maxCodeSize = Math.max(...data.children.map(d => d.size))
            }

            assert(maxCodeSize)

            for(const d of data.children) {
                let li = document.createElement("li")
                li.className = "image-row"
                d.html_imageview = li
                ul.appendChild(li)
                let span = document.createElement("span")
                li.appendChild(span)

                {
                    let totalSizeColumn = document.createElement("span")
                    totalSizeColumn.className = "total-size-column"
                    totalSizeColumn.textContent = formatByteSizesWithUnitPrefix(d.size)
                    li.appendChild(totalSizeColumn)
                }

                {
                    let sizeBarOuter = document.createElement("div")
                    sizeBarOuter.className = "size-bar-outer"
                    sizeBarOuter.style.width = (d.size / maxCodeSize * 100) + "%"
                    li.appendChild(sizeBarOuter)

                    let sizeBarInner = document.createElement("div")
                    sizeBarInner.className = "size-bar-inner"
                    sizeBarOuter.appendChild(sizeBarInner)
                }

                {
                    let purgePercentageBarOuter = document.createElement("div")
                    purgePercentageBarOuter.className = "purge-percentage-bar-outer"
                    li.appendChild(purgePercentageBarOuter)

                    let purgePercentageBarInner = document.createElement("div")
                    purgePercentageBarInner.className = "purge-percentage-bar-inner"
                    purgePercentageBarOuter.appendChild(purgePercentageBarInner)

                    let purgePercentageBarText = document.createElement("span")
                    purgePercentageBarText.className = "purge-percentage-bar-text"
                    purgePercentageBarOuter.appendChild(purgePercentageBarText)
                }

                let node = d
                span.className = "caret"
                if (d.children) {
                    span.addEventListener("click", () => {
                        expandClickHandler(span, node, () => {
                            li.appendChild(generateHtmlImageview(node))
                            node.children.forEach(refreshPurgeValueForImageviewNode)
                        });
                    });
                } else {
                    span.style.visibility = "hidden"
                }
                li.appendChild(span)

                let nameSpan = document.createElement("span")
                nameSpan.appendChild(document.createTextNode(d.name))
                //nameSpan.title = d.fullname
                nameSpan.className = "node-text"
                li.appendChild(nameSpan)

                nameSpan.addEventListener("click", async () =>  {
                    const mid = node.cg_nodes[0]
                    if (!mid)
                        return

                    if (detailMid === mid) {
                        nameSpan.classList.remove("selected-for-detail")
                        detailMid = undefined
                    } else {
                        nameSpan.classList.add("selected-for-detail")
                        detailMid = mid
                    }

                    const edges = detailMid ? getReachabilityHyperpath(detailMid) : []
                    renderGraphOnDetailView(edges, detailMid)
                })
            }

            let child_sizes = data.children.map(cn => cn.size)

            let order = new Array(data.children.length)
            for(let i = 0; i < order.length; i++)
                order[i] = i

            let nodes = ul.children
            order.sort((a, b) => child_sizes[b] - child_sizes[a]).map(i => nodes[i]).forEach(node => ul.appendChild(node))

            return ul
        }

        function prepareListView(data) {
            {
                const rootTreeViewElement = document.getElementById("cut-overview-root")
                insertChildren(rootTreeViewElement, data)
                const list = rootTreeViewElement.querySelector('ul')
                list.classList.remove("nested")
                list.classList.add("unpadded")
                list.classList.add("active")
            }
            {
                const rootTreeViewElement = document.getElementById("imageview-root")
                const list = generateHtmlImageview(data)
                rootTreeViewElement.appendChild(list)
                list.classList.remove("nested")
                list.classList.add("unpadded")
                list.classList.add("active")
            }
        }

        let reachable_under_selection
        let reachable_in_image_view // Also has the purges of current hover

        function createPurgeNodeTree(node) {
            let root = { src: node }

            let mids = []
            if (node.cg_nodes)
                mids = node.cg_nodes

            let children = []
            if (node.children) {
                for(const child of node.children) {
                    if (selectedForPurging.has(child))
                        continue;
                    if (child.html) {
                        const child_root = createPurgeNodeTree(child)
                        if (child_root)
                            children.push(child_root)
                    } else {
                        mids = mids.concat(collectCgNodesInSubtree(child))
                    }
                }
            }

            if (children.length === 0 && mids.length === 0)
                return undefined

            if (mids.length !== 0)
                root.mids = mids

            if (children.length !== 0)
                root.children = children

            return root
        }

        let maxPurgedSize

        function recalculateCutOverviewCustom(purgeNodeTreeRoot, additionalPurges, callback) {
            simulatePurgesBatched(purgeNodeTreeRoot, (node, still_reachable) => {
                let purgedSize = 0
                for (let i = 0; i < codesizes.length; i++)
                    if (reachable_under_selection[i] !== 0xFF && still_reachable[i] === 0xFF)
                        purgedSize += codesizes[i]
                if (node.src)
                    callback(node.src, { arr: still_reachable.slice(), size: purgedSize })
            }, additionalPurges)
        }

        function precomputeCutOverview() {
            for (const node of [...selectedForPurging]) {
                node.reachable_after_additionally_cutting_this = { arr: reachable_under_selection, size: 0 }
            }

            const purgeNodeTreeRoot = createPurgeNodeTree(this.dataRoot)

            recalculateCutOverviewCustom(purgeNodeTreeRoot, [...new Set([...selectedForPurging].flatMap(collectCgNodesInSubtree))], (node, data) => {
                node.reachable_after_additionally_cutting_this = data
            })

            assert(this.maxPurgedSize)

            forEachInSubtree(this.dataRoot, u => {
                const html = u.html
                if (!html)
                    return
                const purged = u.reachable_after_additionally_cutting_this
                if (!purged)
                    return

                html.querySelector('.cut-size-column').textContent = formatByteSizesWithUnitPrefix(purged.size)
                html.querySelector('.cut-size-bar').style.width = (purged.size / this.maxPurgedSize * 100) + "%"
            })

            /* sorting...
            forEachInSubtree(this.dataRoot, u => {
                if(!u.children)
                    return

                let list
                if(u === this.dataRoot) {
                    list = document.getElementById("cut-overview-root").children[0]
                } else if (!u.html) {
                    return
                } else {
                    list = u.html.querySelector("ul")
                }

                const nodes = u.children
                nodes.sort((a, b) => b.purgedSize - a.purgedSize).map(n => n.html).filter(node => node).forEach(node => list.appendChild(node))
            })
             */
        }

        function recalculateCutOverviewForSubtree(list, node) {
            // The C++ code doesn't handle empty groups well. Therefore we already handle them here.
            let purgeNodeTreeRoot = { children: node.children.map((c, i) => { return { mids: collectCgNodesInSubtree(c), index: i, src: c } }).filter(n => n.mids.length > 0) }

            let maxPurgedSize = 0
            recalculateCutOverviewCustom(purgeNodeTreeRoot, [], (node, data) => {
                node.reachable_after_cutting_this = data
                maxPurgedSize = Math.max(maxPurgedSize, data.size)
            })

            if (node === this.dataRoot)
                this.maxPurgedSize = maxPurgedSize

            assert(this.maxPurgedSize)

            function sortKey(a) {
                if(a.reachable_after_cutting_this)
                    return a.reachable_after_cutting_this.size
                else
                    return -1
            }

            node.children.sort((a, b) => sortKey(b) - sortKey(a)).map(n => n.html).forEach(node => list.appendChild(node))

            if (precomputeCutoffs && selectedForPurging.size > 0) {
                recalculateCutOverviewCustom(purgeNodeTreeRoot, [...new Set([...selectedForPurging].flatMap(collectCgNodesInSubtree))], (node, data) => {
                    node.reachable_after_additionally_cutting_this = data
                })
            }

            for (const c of node.children) {
                const purged = c.reachable_after_additionally_cutting_this ?? c.reachable_after_cutting_this
                if(!purged)
                    return;
                const purgedSize = purged.size
                c.html.querySelector('.cut-size-column').textContent = formatByteSizesWithUnitPrefix(purgedSize)
                c.html.querySelector('.cut-size-bar').style.width = (purgedSize / this.maxPurgedSize * 100) + "%"
            }
        }

        function updatePurgeValues() {
            forEachInSubtree(this.dataRoot, (u) => {
                if (u.html_imageview) {
                    refreshPurgeValueForImageviewNode(u)
                }
            })
        }

        function refreshPurgeValueForImageviewNode(u) {
            const all_reachable = Module.HEAPU8.subarray(all_reachable_ptr, all_reachable_ptr + codesizes.length)
            const still_reachable = reachable_in_image_view ?? all_reachable

            let purgedCodesize = 0
            forEachInSubtree(u, (v) => {
                if (v.cg_nodes)
                    for (const i of v.cg_nodes)
                        if (all_reachable[i] !== 0xFF && still_reachable[i] === 0xFF)
                            purgedCodesize += codesizes[i]
            })
            let purgedPercentage = 100 * purgedCodesize / u.size
            let barWidth = 0
            let percentageText = ""
            if (u.size !== 0) {
                barWidth = purgedPercentage.toFixed(1) + "%"
                percentageText = purgedPercentage === 0 ? "" : purgedPercentage.toFixed(1) + " %"
            }
            u.html_imageview.querySelector(".purge-percentage-bar-text").textContent = percentageText
            u.html_imageview.querySelector(".purge-percentage-bar-inner").style.width = barWidth
            u.html_imageview.querySelector(".size-bar-inner").style.width = barWidth
        }

        function getUnqualifiedCausalityGraphNodeName(fullyQualifiedName) {
            return fullyQualifiedName.replaceAll(/(?<![A-Za-z0-9])([a-z]\w+\.)+/g, "")
        }

        function getColorAccordingToCausalityGraphNodeType(fullyQualifiedName) {
            if(fullyQualifiedName.endsWith("[Instantiated]"))
                return "#FF4040"
            if(fullyQualifiedName.endsWith("[Reflection Registration]"))
                return "#D0A000"
            if(fullyQualifiedName.endsWith("[JNI Registration]"))
                return "#904040"
            if(fullyQualifiedName.endsWith("[Configuration File]"))
                return "#505050"
            if(fullyQualifiedName.endsWith("[Initial Registrations]"))
                return "#C0C0C0"
            if(fullyQualifiedName.endsWith("[User-Requrested Feature Registration"))
                return "#808080"
            if(fullyQualifiedName.endsWith("[Automatic Feature Registration]"))
                return "#A0A0A0"
            if(fullyQualifiedName.endsWith("[Unknown Heap Object]"))
                return "#1010E0"
            if(fullyQualifiedName.endsWith("[Build-Time]"))
                return "#4040FF"
            if(fullyQualifiedName.endsWith("[Reachability Callback]"))
                return "#E0E000"
            if(fullyQualifiedName.includes("(")) // Method reachable
                return "#20C020"

            // Class reachable
            return "#40A0DF"
        }

        function renderGraphOnDetailView(edges, targetMid) {
            const htmlSvg = document.getElementById("chart")
            htmlSvg.textContent = ""

            if (edges.length === 0)
                return


            // Graph construction
            graph = {nodes: new Set(), links: []};

            edges.forEach(function (e) {
                if(e.src === -1 || e.dst === -1)
                    return

                graph.nodes.add(e.src);
                graph.nodes.add(e.dst);
                let newObj = { source: e.src, target: e.dst }
                if (e.via_type)
                    newObj.via_type = e.via_type
                graph.links.push(newObj);
            });

            graph.nodes = [...graph.nodes]

            // Modeling adjacency through indices
            graph.links.forEach(function (d, i) {
                graph.links[i].source = graph.nodes.indexOf(graph.links[i].source);
                graph.links[i].target = graph.nodes.indexOf(graph.links[i].target);
            });

            // Store index at each node
            graph.nodes.forEach(function (d, i) {
                graph.nodes[i] = { index: i, mid: d, name: methodList[d] ?? "<root>", adj: [], in_deg: 0 };
            });

            graph.links.forEach(l => {
                graph.nodes[l.source].adj.push(l)
                graph.nodes[l.target].in_deg++
            })

            let order = []

            for(let v = 0; v < graph.nodes.length; v++)
                if(graph.nodes[v].in_deg === 0)
                    order.push(v)
            for(let i = 0; i < order.length; i++)
                for(const e of graph.nodes[order[i]].adj) {
                    const v = e.target
                    graph.nodes[v].in_deg--
                    if(graph.nodes[v].in_deg === 0)
                        order.push(v)
                }

            order = order.reverse()

            let maxDepth = 0

            for(const u of order) {
                let depth = 0
                for(const e of graph.nodes[u].adj) {
                    const v = e.target
                    if(graph.nodes[v].depth + 1 > depth)
                        depth = graph.nodes[v].depth + 1
                }
                graph.nodes[u].depth = depth
                if(depth > maxDepth)
                    maxDepth = depth
            }

            function applyLayering(n) {
                if(!n)
                    return
                n.value = n.data.depth
                if(n.dataChildren)
                    for(const c of n.dataChildren) {
                        applyLayering(c.child)
                    }
            }

            const dag = d3.dagStratify()
                .id(({index}) => index.toString())
                .parentData(({adj}) => adj.map(e => [e.target.toString(), e]))
                (graph.nodes);
            const nodeRadius = 20;
            const layout = d3
                .sugiyama() // base layout
                //.layering(applyLayering)
                .decross(d3.decrossTwoLayer()) // minimize number of crossings
                .nodeSize((node) => [(node ? 3.6 : 0.25) * nodeRadius, 3 * nodeRadius]); // set node size instead of constraining to fit
            const { width, height } = layout(dag);
            const x0 = 0;
            const x1 = width;
            const y0 = 0;
            const y1 = height;

            // --------------------------------
            // This code only handles rendering
            // --------------------------------
            const outerSvg = d3.select("#detail-svg")
            outerSvg.attr("viewBox", [0, 0, width, height].join(" "));
            const svgSelection = d3.select("#chart");
            const defs = svgSelection.append("defs"); // For gradients

            const steps = dag.size();
            const interp = d3.interpolateRainbow;
            const colorMap = new Map();
            for (const [i, node] of dag.idescendants().entries()) {
                colorMap.set(node.data.id, interp(i / steps));
            }

            // How to draw edges
            const line = d3
                .line()
                .curve(d3.curveCatmullRom)
                .x((d) => d.x)
                .y((d) => d.y);

            // Plot edges
            const links = svgSelection
                .append("g")
                .selectAll("path")
                .data(dag.links())
                .enter()
                .append("path")
                .attr("d", ({ points }) => line(points))
                .attr("fill", "none")
                .attr("stroke-width", 3)
                .attr("stroke", ({source, target, data}) => {
                    if(data.via_type !== undefined) {
                        return "#40FF40"
                    } else {
                        return "#808080"
                    }


                    // encodeURIComponents for spaces, hope id doesn't have a `--` in it
                    const gradId = encodeURIComponent(`${source.data.id}--${target.data.id}`);
                    const grad = defs
                        .append("linearGradient")
                        .attr("id", gradId)
                        .attr("gradientUnits", "userSpaceOnUse")
                        .attr("x1", source.x)
                        .attr("x2", target.x)
                        .attr("y1", source.y)
                        .attr("y2", target.y);
                    grad
                        .append("stop")
                        .attr("offset", "0%")
                        .attr("stop-color", colorMap.get(source.data.id));
                    grad
                        .append("stop")
                        .attr("offset", "100%")
                        .attr("stop-color", colorMap.get(target.data.id));
                    return `url(#${gradId})`;
                });

            links
                .append("title")
                .text(({data}) => data.via_type !== undefined ? typeList[data.via_type] : undefined)

            // Select nodes
            const nodes = svgSelection
                .append("g")
                .selectAll("g")
                .data(dag.descendants())
                .enter()
                .append("g")
                .attr("transform", ({ x, y }) => `translate(${x}, ${y})`);

            // Plot node circles
            const nodeCircles = nodes
                .append("circle")

            nodeCircles
                .attr("r", nodeRadius)
                .attr("fill", d => getColorAccordingToCausalityGraphNodeType(d.data.name))

            nodes
                .append("title")
                .text(d => d.data.name)

            const textSize = Math.max(width, height) / 100

            // Add text to nodes
            nodes
                .append("text")
                .text((d) => getUnqualifiedCausalityGraphNodeName(d.data.name))
                .attr("font-family", "sans-serif")
                .attr("text-anchor", "left")
                .attr("fill", "black")
                .attr("font-size", textSize)


            function onZoom() {
                transform = d3.zoomTransform(d3.select("#chartpanel").node());

                function transX(num)
                {
                    return num
                    return num * transform.k + transform.x;
                }

                function transY(num)
                {
                    return num * transform.k + transform.y;
                }

                nodes
                    .attr("transform", ({x, y}) => `translate(${transX(x)}, ${transY(y)})`)
                nodeCircles
                    .attr("r", transform.k * nodeRadius)

                links.attr("d", ({ points }) => line(points.map(({x, y}) => {return {x: transX(x), y: transY(y)}})))
                    .attr("stroke-width", transform.k * 3)
                /*
                link
                    .attr("x1", d => transX(d.source.x * 0.9 + d.target.x * 0.1))
                    .attr("y1", d => transY(d.source.y * 0.9 + d.target.y * 0.1))
                    .attr("x2", d => transX(d.target.x * 0.9 + d.source.x * 0.1))
                    .attr("y2", d => transY(d.target.y * 0.9 + d.source.y * 0.1));

                node
                    .attr("cx", d => transX(d.x))
                    .attr("cy", d => transY(d.y));

                nodeText
                    .attr("x", d => transX(d.x))
                    .attr("y", d => transY(d.y));

                 */
            }

            var zoom = d3.zoom().on("zoom", onZoom);
            d3.select("#chartpanel").call(zoom);
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Causality Graph Text Interface</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <script src="lib/causality_graph.js"></script>
    <script src="zip.min.js"></script>
    <script>
        let simulate_purge = Module.cwrap("simulate_purge", "number", ["number", "number"]);
        let simulate_purges_batched = Module.cwrap("simulate_purges_batched", "number", ["number", "number", "number"])
        let show_reachability = Module.cwrap("show_reachability", "number", ["number"]);
        let init = Module.cwrap("init", "number", ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);

        let all_reachable

        function simulatePurge(purge_group) {
            let midsPtr = Module._malloc(purge_group.length * 4)
            let midsArray = Module.HEAPU32.subarray(midsPtr / 4, midsPtr / 4 + purge_group.length)

            for (let i = 0; i < purge_group.length; i++)
                midsArray[i] = purge_group[i] + 1

            let method_history_ptr = simulate_purge(midsPtr, purge_group.length)
            // dealloc memory
            Module._free(midsPtr);

            return Module.HEAPU8.subarray(method_history_ptr, method_history_ptr + codesizes.length)
        }

        function simulatePurgesBatched(purge_groups, resultCallback) {
            let subsetsArrPtr = Module._malloc(purge_groups.length * 2 /* {ptr, len} */ * 4 /* (4 byte ptr/len) */)
            let subsetsArr = Module.HEAPU32.subarray(subsetsArrPtr / 4, subsetsArrPtr / 4 + purge_groups.length * 2)

            let totalCount = 0// = purge_groups.reduce((cnt, group) => cnt + group.length, 0)
            for(const group of purge_groups)
                totalCount += group.length

            let midsPtr = Module._malloc(totalCount * 4)
            let midsPos = midsPtr / 4

            for(let i = 0; i < purge_groups.length; i++)
            {
                subsetsArr[i*2] /* ptr */ = midsPos * 4
                subsetsArr[i * 2 + 1] /* len */ = purge_groups[i].length
                for(const mid of purge_groups[i])
                    Module.HEAPU32[midsPos++] = mid + 1
            }

            assert(midsPos * 4 === midsPtr + totalCount * 4)

            const callback = (iteration, method_history_ptr) => {
                const still_reachable = Module.HEAPU8.subarray(method_history_ptr, method_history_ptr + codesizes.length)
                let purged_size = 0
                for (let i = 0; i < codesizes.length; i++)
                    if (all_reachable[i] !== 0xFF && still_reachable[i] === 0xFF)
                        purged_size += codesizes[i]
                resultCallback(iteration, purged_size)
                return 0
            }

            const callback_ptr = addFunction(callback, 'iii')
            const status = simulate_purges_batched(subsetsArrPtr, purge_groups.length, callback_ptr)
            removeFunction(callback_ptr)

            Module._free(subsetsArrPtr)
            Module._free(midsPtr)

            if(status === 0)
                throw new Error("simulate_purges_batched exited with error code " + status)
        }

        function pressBtn(str) {
            throw Error("Currently not implemented properly!!!")
            document.getElementById("Output").value = simulatePurge(str)
            printReachability(document.getElementById("Input_reachability").value)
        }

        function printReachability(str){
            let ptr  = allocateUTF8(str)

            let retPtr = show_reachability(ptr)

            document.getElementById("Output_reachability").value = UTF8ToString(retPtr)

            // dealloc memory
            Module._free(ptr);
            Module._free(retPtr);
        }

        const model = (() => {

            return {
                getEntries(file, options) {
                    return (new zip.ZipReader(new zip.BlobReader(file))).getEntries(options);
                },
                async getURL(entry, options) {
                    return URL.createObjectURL(await entry.getData(new zip.BlobWriter(), options));
                }
            };

        })();

        function doSomething(){
            let fileInput = document.getElementById("file-input");
            fileInput.dispatchEvent(new MouseEvent("click"));
            fileInput.onchange = selectFile;
        }

        async function selectFile() {
            try {
                let fileInput = document.getElementById("file-input");
                let selectedFile = fileInput.files[0];
                await loadFiles(selectedFile, "utf-8");
            } catch (error) {
                alert(error);
            }
        }

        function getMethodCodesizeDictFromReachabilityJson(data) {
            let dict = {}

            for (const toplevel of data) {
                for (const packageName in toplevel.packages) {
                    const package = toplevel.packages[packageName]
                    for (const typeName in package.types) {
                        const type = package.types[typeName]
                        for (const methodName in type.methods) {
                            const method = type.methods[methodName]
                            const fullyQualifiedName = `${packageName}.${typeName}.${methodName}`
                            dict[fullyQualifiedName] = method.size
                        }
                    }
                }
            }

            return dict
        }

        async function loadFiles(selectedFile, filenameEncoding) {
            let entries = await model.getEntries(selectedFile, { filenameEncoding });
            if (entries && entries.length) {
                filesAsByteArrays = {}

                let reachabilityData = JSON.parse(await entries.find(e => e.filename === "reachability.json").getData(new zip.TextWriter()))
                let methods = await entries.find(e => e.filename === "methods.txt").getData(new zip.TextWriter())
                methodList = methods.split('\n')
                if(methodList[methodList.length-1].length === 0) {
                    methodList.pop()
                }
                let codesizesDict = getMethodCodesizeDictFromReachabilityJson(reachabilityData)
                codesizes = new Array(methodList.length)

                for(let i = 0; i < methodList.length; i++) {
                    codesizes[i] = codesizesDict[methodList[i]] ?? 0
                }


                for (const entry of entries) {
                    if(entry.filename === "reachability.json")
                    {
                        continue;
                    }

                    const zipFileWriter = new zip.Uint8ArrayWriter()
                    const data = await entry.getData(zipFileWriter)

                    let input_ptr = Module._malloc(data.length);
                    Module.HEAPU8.set(data, input_ptr);

                    filesAsByteArrays[entry.filename] = { data: input_ptr, length: data.length }
                }

                const all_method_history_ptr = init(filesAsByteArrays["types.txt"].data, filesAsByteArrays["types.txt"].length,
                    filesAsByteArrays["methods.txt"].data, filesAsByteArrays["methods.txt"].length,
                    filesAsByteArrays["typeflows.txt"].data, filesAsByteArrays["typeflows.txt"].length,
                    filesAsByteArrays["typestates.bin"].data, filesAsByteArrays["typestates.bin"].length,
                    filesAsByteArrays["interflows.bin"].data, filesAsByteArrays["interflows.bin"].length,
                    filesAsByteArrays["direct_invokes.bin"].data, filesAsByteArrays["direct_invokes.bin"].length,
                    filesAsByteArrays["typeflow_methods.bin"].data, filesAsByteArrays["typeflow_methods.bin"].length,
                    filesAsByteArrays["typeflow_filters.bin"].data, filesAsByteArrays["typeflow_filters.bin"].length,
                    filesAsByteArrays["declaring_types.bin"].data, filesAsByteArrays["declaring_types.bin"].length,
                )

                for (const span of Object.values(filesAsByteArrays))
                    Module._free(span.data)

                all_reachable = Module.HEAPU8.subarray(all_method_history_ptr, all_method_history_ptr + codesizes.length)
                prepareListView(generateHierarchyFromReachabilityJsonAndMethodList(reachabilityData, methodList))
            }
        }
    </script>


    <details hidden>

        <br/>
        <label for="Input"></label><textarea id="Input" cols="100" rows="5" spellcheck="false" oninput="pressBtn(this.value)"></textarea>
        <label for="Input_reachability"></label><textarea id="Input_reachability" cols="100" rows="5" spellcheck="false" oninput="printReachability(this.value)"></textarea>
        <br/>
        <label for="Output"></label><textarea id="Output" cols="100" spellcheck="false" rows="20" readonly="readonly"></textarea>
        <label for="Output_reachability"></label><textarea id="Output_reachability" cols="100" spellcheck="false" rows="20" readonly="readonly"></textarea>
    </details>

    <div class="top-panel">
        <input type="file" id="file-input" accept="application/zip" hidden>
        <button title="upload" onClick="doSomething()"><big>Upload CausalityExport</big></button>
    </div>

    <div class="main-panel">
        <div class="overview-div">
            <span><b>Cut Overview:</b></span>
            <div id="cut-overview-root"></div>
        </div>
        <div class="imageview-div">
            <span><b>In-Image Overview:</b></span>
            <div id="imageview-root"></div>
        </div>
        <div class="detail-div">
            <label for="Output_hoverpurge"></label><textarea placeholder="Events made unreachable" wrap="off" style="width: 100%; height: 100%" id="Output_hoverpurge" spellcheck="false" rows="50" readonly="readonly"></textarea>
        </div>
    </div>

    <script>
        class Trie {
            constructor(dict) {
                this.root = { next: {} }
                for (const str in dict) {
                    let node = this.root
                    for (const c of str) {
                        if (!node.next[c]) {
                            node.next[c] = { next: {} }
                        }
                        node = node.next[c]
                    }
                    node.val = dict[str]
                }
            }

            find(str) {
                let node = this.root
                let val = undefined
                for (const c of str) {
                    if (!node.next[c])
                        return val
                    node = node.next[c]
                    if (node.val)
                        val = node.val
                }
                return val
            }
        }
    </script>
    <script>
        let selectedForPurging = new Set()

        function generateHierarchyFromReachabilityJsonAndMethodList(json, cgNodes) {
            let dict = { children: [] }

            prefixToNode = {}

            for (const toplevel of json) {
                let l1name = "ϵ"
                let l1fullname = ""

                let display_path = toplevel.path
                if (display_path && display_path.endsWith(".jar")) {
                    let index = display_path.lastIndexOf("/")
                    if (index !== -1) {
                        display_path = display_path.substring(index+1)
                    }
                }

                if (toplevel.path && toplevel.module) {
                    l1name = display_path + ":" + toplevel.module
                    l1fullname = toplevel.path + ":" + toplevel.module
                } else if(toplevel.path) {
                    l1name = display_path
                    l1fullname = toplevel.path
                } else if(toplevel.module) {
                    l1name = toplevel.module
                    l1fullname = toplevel.module
                }

                let l1 = { children: [], name: l1name, fullname: l1fullname, cg_nodes: [] }
                if (toplevel.path) {
                    prefixToNode[toplevel.path] = l1
                }
                dict.children.push(l1)

                for (const packageName in toplevel.packages) {
                    const package = toplevel.packages[packageName]
                    let prefix = ""
                    let l2 = l1

                    if(packageName.length !== 0) {
                        for (const subPackageName of packageName.split('.')) {
                            prefix += subPackageName + "."
                            let next = l2.children.find(n => n.name === subPackageName)
                            if(!next) {
                                next = { children: [], fullname: prefix, name: subPackageName, cg_nodes: [] }

                                /* Eigentlich sollten keine Causality-Graph-Knoten direkt in einem Package hängen.
                                 * Es gibt jedoch Knoten für Klassen, die nicht reachable sind (z.B. Build-Time-Features).
                                 * Diese müssen unbedingt in die Abschneide-Berechnung miteinbezogen werden.
                                 * Idealerweise sollten sie auch in der Baumstruktur auftauchen.
                                 * Das ist aber gerade noch zu kompliziert umzusetzen... */
                                prefixToNode[prefix] = next

                                l2.children.push(next)
                            }
                            l2 = next
                        }
                    }

                    for (const typeName in package.types) {
                        const type = package.types[typeName]
                        let l3 = { children: [], fullname: prefix + typeName, name: typeName, cg_nodes: [] }
                        prefixToNode[l3.fullname] = l3
                        l2.children.push(l3)

                        for (const method in type.methods) {
                            let l4 = { fullname: l3.fullname + "." + method, name: method, cg_nodes: [] }
                            prefixToNode[l4.fullname] = l4
                            l3.children.push(l4)
                        }
                    }
                }
            }

            const trie = new Trie(prefixToNode)

            for (let i = 0; i < cgNodes.length; i++) {
                const cgNodeName = cgNodes[i]
                const node = trie.find(cgNodeName)
                if (node)
                    node.cg_nodes.push(i)
            }

            return dict
        }

        function formatByteSizesWithUnitPrefix(size) {
            if(size > 1000000)
                return (size / 1000000).toPrecision(3) + " MB"
            else if(size > 1000)
                return (size / 1000).toPrecision(3) + " KB"
            else
                return size.toPrecision(3) + " B"
        }

        function forEachInSubtree(node, callback) {
            let stack = []
            stack.push(node)
            while (stack.length > 0) {
                const u = stack.pop()
                if (u.children)
                    stack = stack.concat(u.children)
                callback(u)
            }
        }

        function collectCgNodesInSubtree(node) {
            let group = []
            forEachInSubtree(node, u => {
                if (u.cg_nodes)
                    group = group.concat(u.cg_nodes)
            })
            return group
        }

        function insertChildren(element, node) {
            let list = generateHTML(node)
            element.appendChild(list)
            calculateAggregateCutWeight(list, node)
        }

        function calculateAggregateCutWeight(list, node) {
            let purge_groups = node.children.map(collectCgNodesInSubtree)

            let res = Array(purge_groups.length)

            // The C++ code doesn't handle empty groups well. Therefore we already handle them here.
            let nonempty_purge_groups_indexes = []
            for (let i = 0; i < purge_groups.length; i++) {
                if (purge_groups[i].length > 0)
                    nonempty_purge_groups_indexes.push(i)
                else
                    res[i] = 0
            }

            let nonempty_purge_groups = purge_groups.filter(g => g.length > 0)
            nonempty_res = simulatePurgesBatched(nonempty_purge_groups, (iteration, size) => {
                i = nonempty_purge_groups_indexes[iteration]
                res[i] = size
            })

            for (let i = 0; i < list.children.length; i++)
                list.children[i].querySelector('#purged').textContent = formatByteSizesWithUnitPrefix(res[i])

            let order = new Array(list.children.length)
            for(let i = 0; i < order.length; i++)
                order[i] = i

            let nodes = list.children
            order.sort((a, b) => res[b] - res[a]).map(i => nodes[i]).forEach(node => list.appendChild(node))
        }

        function calculateAggregateSize(list, node) {
            for (let i = 0; i < list.children.length; i++)
                list.children[i].querySelector('#purged').textContent = formatByteSizesWithUnitPrefix(res[i])

            let order = new Array(list.children.length)
            for(let i = 0; i < order.length; i++)
                order[i] = i

            let nodes = list.children
            order.sort((a, b) => res[b] - res[a]).map(i => nodes[i]).forEach(node => list.appendChild(node))
        }

        function expandClickHandler(element, node, populateCallback) {
            let expanded = element.classList.toggle("caret-down");

            if(!element.parentElement.querySelector(".nested") && expanded) {
                populateCallback()
            }

            element.parentElement.querySelector(".nested").classList.toggle("active");
        }

        function generateHTML(data) {
            let ul = document.createElement("ul")
            ul.className = "nested"

            for(const d of data.children) {
                let li = document.createElement("li")
                li.className = "row"
                d.html = li
                ul.appendChild(li)

                let out = document.createElement("span")
                out.className = "cut-size-column"
                out.id = "purged"
                li.appendChild(out)

                let node = d
                if (d.children) {
                    let span = document.createElement("span")
                    span.className = "caret"
                    span.addEventListener("click", () => {
                        expandClickHandler(span, node, () => insertChildren(li, node));
                    });
                    li.appendChild(span)
                }

                let nameSpan = document.createElement("span")
                nameSpan.appendChild(document.createTextNode(d.name))
                nameSpan.title = d.fullname
                nameSpan.className = "node-text"
                li.appendChild(nameSpan)

                nameSpan.addEventListener("click", () => {
                    let selected = nameSpan.classList.toggle("selected-for-purge")
                    if (selected)
                        selectedForPurging.add(node)
                    else
                        selectedForPurging.delete(node)
                    updatePurgeValues()
                })
            }

            return ul
        }

        function generateHtmlImageview(data) {
            let ul = document.createElement("ul")
            ul.className = "nested"

            for(const d of data.children) {
                let li = document.createElement("li")
                d.html_imageview = li
                ul.appendChild(li)
                let span = document.createElement("span")
                li.appendChild(span)

                let nameSpan = document.createElement("span")
                nameSpan.appendChild(document.createTextNode(d.name))
                nameSpan.title = d.fullname
                nameSpan.className = "node-text"
                li.appendChild(nameSpan)

                let out3 = document.createElement("span")
                out3.className = "total-size-column"
                out3.id = "size"
                li.appendChild(out3)

                let out4 = document.createElement("div")
                out4.className = "size-bar-outer"
                li.appendChild(out4)

                let out5 = document.createElement("div")
                out5.className = "size-bar-inner"
                out5.id = "purged_of_bar"
                out4.appendChild(out5)

                let out2 = document.createElement("span")
                out2.className = "size-bar-text"
                out2.id = "purged_of"
                out4.appendChild(out2)

                {
                    let codesize = 0
                    forEachInSubtree(d, (v) => {
                        if (v.cg_nodes)
                            for (const i of v.cg_nodes)
                                codesize += codesizes[i]
                    })
                    d.size = codesize
                    out3.textContent = formatByteSizesWithUnitPrefix(codesize)
                }

                let node = d
                if(d.children) {
                    span.className = "caret"
                    span.addEventListener("click", () => {
                        expandClickHandler(span, node, () => li.appendChild(generateHtmlImageview(node)));
                    });
                }
            }

            let child_sizes = data.children.map(cn => cn.size)

            let order = new Array(data.children.length)
            for(let i = 0; i < order.length; i++)
                order[i] = i

            let nodes = ul.children
            order.sort((a, b) => child_sizes[b] - child_sizes[a]).map(i => nodes[i]).forEach(node => ul.appendChild(node))

            return ul
        }

        function prepareListView(data) {
            this.dataRoot = data
            {
                const rootTreeViewElement = document.getElementById("cut-overview-root")
                insertChildren(rootTreeViewElement, data)
                const list = rootTreeViewElement.querySelector('ul')
                list.classList.remove("nested")
                list.classList.add("unpadded")
                list.classList.add("active")
            }
            {
                const rootTreeViewElement = document.getElementById("imageview-root")
                const list = generateHtmlImageview(data)
                rootTreeViewElement.appendChild(list)
                list.classList.remove("nested")
                list.classList.add("unpadded")
                list.classList.add("active")
            }
        }

        function updatePurgeValues() {
            const still_reachable = simulatePurge([...new Set([...selectedForPurging].flatMap(collectCgNodesInSubtree))])

            let purgedMethodNames = ""
            for (let i = 0; i < codesizes.length; i++)
                if (all_reachable[i] !== 0xFF && still_reachable[i] === 0xFF)
                    purgedMethodNames += methodList[i] + "\n"

            document.getElementById("Output_hoverpurge").value = purgedMethodNames

            forEachInSubtree(this.dataRoot, (u) => {
                if (u.html_imageview) {
                    let purgedCodesize = 0
                    forEachInSubtree(u, (v) => {
                        if (v.cg_nodes)
                            for (const i of v.cg_nodes)
                                if (all_reachable[i] !== 0xFF && still_reachable[i] === 0xFF)
                                    purgedCodesize += codesizes[i]
                    })
                    let purgedPercentage = 100 * purgedCodesize / u.size
                    let barWidth = 0
                    let percentageText = ""
                    if (u.size !== 0) {
                        barWidth = purgedPercentage.toFixed(1) + "%"
                        percentageText = purgedPercentage.toFixed(1) + " %"
                    }
                    u.html_imageview.querySelector("#purged_of").textContent = percentageText
                    u.html_imageview.querySelector("#purged_of_bar").style.width = barWidth
                }
            })
        }
    </script>
</body>
</html>

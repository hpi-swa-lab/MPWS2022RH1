<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Causality Graph Text Interface</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <script src="lib/causality_graph.js"></script>
    <script src="zip.min.js"></script>
    <script>
        let simulate_purge = Module.cwrap("simulate_purge", "number", ["number", "number"]);
        let simulate_purges_batched = Module.cwrap("simulate_purges_batched", "number", ["number", "number"])
        let show_reachability = Module.cwrap("show_reachability", "number", ["number"]);
        let init = Module.cwrap("init", "number", ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);

        let all_reachable_ptr

        function simulatePurge(purge_group) {
            let midsPtr = Module._malloc(purge_group.length * 4)
            let midsArray = Module.HEAPU32.subarray(midsPtr / 4, midsPtr / 4 + purge_group.length)

            for (let i = 0; i < purge_group.length; i++)
                midsArray[i] = purge_group[i] + 1

            let method_history_ptr = simulate_purge(midsPtr, purge_group.length)
            // dealloc memory
            Module._free(midsPtr);

            return method_history_ptr
        }

        function calcPurgeNodesCount(purge_root) {
            let cnt = 1
            if(purge_root.mids && purge_root.children)
                cnt++
            if(purge_root.children)
                for(const child of purge_root.children)
                    cnt += calcPurgeNodesCount(child)
            return cnt
        }

        function calcMidsCount(purge_root) {
            let cnt = 0
            if(purge_root.mids)
                cnt += purge_root.mids.length
            if(purge_root.children)
                for(const child of purge_root.children)
                    cnt += calcMidsCount(child)
            return cnt
        }

        function simulatePurgesBatched(purge_root, resultCallback, prepurgeMids = []) {

            let purgeNodesCount = calcPurgeNodesCount(purge_root)

            let subsetsArrLen = (purgeNodesCount) * 4 /* {{ptr, len}, {child_ptr, child_len}} */
            let subsetsArrPtr = Module._malloc(subsetsArrLen * 4 /* (4 byte ptr/len) */)
            let subsetsArr = Module.HEAPU32.subarray(subsetsArrPtr / 4, subsetsArrPtr / 4 + subsetsArrLen)

            let midsCount = calcMidsCount(purge_root) + prepurgeMids.length

            let midsPtr = Module._malloc(midsCount * 4)
            let midsPos = midsPtr / 4

            let indexToInputNode = Array(purgeNodesCount)
            {
                let i = 1

                function layoutChildren(purge_root, offset) {
                    indexToInputNode[offset] = purge_root
                    const midsPos_start = midsPos

                    const i_start = i

                    if (purge_root.mids) {
                        if (purge_root.children) {
                            subsetsArr[i*4] /* ptr */ = midsPos * 4
                            subsetsArr[i*4 + 1] /* len */ = purge_root.mids.length
                            subsetsArr[i*4 + 2] = 0 // no children
                            subsetsArr[i*4 + 3] = 0 // no children
                            i++
                        }
                        for(const mid of purge_root.mids)
                            Module.HEAPU32[midsPos++] = mid + 1
                    }

                    let i_end = i

                    if (purge_root.children) {
                        let local_i = i
                        i += purge_root.children.length
                        i_end = i
                        for (const child of purge_root.children) {
                            layoutChildren(child, local_i)
                            local_i++
                        }
                    }

                    const midsPos_end = midsPos

                    const slice = subsetsArr.subarray(offset*4, (offset+1)*4)
                    slice[0] = midsPos_start * 4
                    slice[1] = midsPos_end - midsPos_start
                    slice[2] = subsetsArrPtr + i_start * 16
                    slice[3] = i_end - i_start
                }

                for (const mid of prepurgeMids)
                    Module.HEAPU32[midsPos++] = mid + 1
                layoutChildren(purge_root, 0)
                subsetsArr[0] = midsPtr // Also include prepurgeMids
            }
            assert(midsPos * 4 === midsPtr + midsCount * 4)

            const callback = (iteration, method_history_ptr) => {
                const inputNode = indexToInputNode[iteration]
                if (!inputNode)
                    return;

                const still_reachable = Module.HEAPU8.subarray(method_history_ptr, method_history_ptr + codesizes.length)
                const all_reachable = Module.HEAPU8.subarray(all_reachable_ptr, all_reachable_ptr + codesizes.length)
                let purged_size = 0
                for (let i = 0; i < codesizes.length; i++)
                    if (all_reachable[i] !== 0xFF && still_reachable[i] === 0xFF)
                        purged_size += codesizes[i]
                resultCallback(inputNode, purged_size)
                return 0
            }

            const callback_ptr = addFunction(callback, 'iii')
            const status = simulate_purges_batched(subsetsArrPtr, callback_ptr)
            removeFunction(callback_ptr)

            Module._free(subsetsArrPtr)
            Module._free(midsPtr)

            if(status === 0)
                throw new Error("simulate_purges_batched exited with error code " + status)
        }

        function printReachability(str){
            let ptr  = allocateUTF8(str)

            let retPtr = show_reachability(ptr)

            document.getElementById("Output_reachability").value = UTF8ToString(retPtr)

            // dealloc memory
            Module._free(ptr);
            Module._free(retPtr);
        }

        const model = (() => {

            return {
                getEntries(file, options) {
                    return (new zip.ZipReader(new zip.BlobReader(file))).getEntries(options);
                },
                async getURL(entry, options) {
                    return URL.createObjectURL(await entry.getData(new zip.BlobWriter(), options));
                }
            };

        })();

        function triggerFileSectionDialog() {
            let fileInput = document.getElementById("file-input");
            fileInput.dispatchEvent(new MouseEvent("click"));
            fileInput.onchange = selectFile;
        }

        function selectFile() {
            const fileInput = document.getElementById("file-input");
            if (fileInput.files.length > 0) {
                tryLoadFile(fileInput.files[0])
            }
        }

        async function tryLoadFile(file) {
            try {
                document.getElementById("fileselect-panel").hidden = true
                document.getElementById("loading-panel").hidden = false
                await loadFiles(file, "utf-8");
                document.getElementById("loading-panel").hidden = true
                document.getElementById("main-panel").hidden = false
            } catch (error) {
                alert(error);
                document.getElementById("loading-panel").hidden = true
                document.getElementById("fileselect-panel").hidden = false
            }
        }

        function getMethodCodesizeDictFromReachabilityJson(data) {
            let dict = {}

            for (const toplevel of data) {
                for (const packageName in toplevel.packages) {
                    const package = toplevel.packages[packageName]
                    for (const typeName in package.types) {
                        const type = package.types[typeName]
                        for (const methodName in type.methods) {
                            const method = type.methods[methodName]
                            const fullyQualifiedName = `${packageName}.${typeName}.${methodName}`
                            dict[fullyQualifiedName] = method.size
                        }
                    }
                }
            }

            return dict
        }

        async function loadFiles(selectedFile, filenameEncoding) {
            let entries = await model.getEntries(selectedFile, { filenameEncoding });
            if (entries && entries.length) {
                filesAsByteArrays = {}

                let reachabilityData = JSON.parse(await entries.find(e => e.filename === "reachability.json").getData(new zip.TextWriter()))
                let methods = await entries.find(e => e.filename === "methods.txt").getData(new zip.TextWriter())
                methodList = methods.split('\n')
                if(methodList[methodList.length-1].length === 0) {
                    methodList.pop()
                }
                let codesizesDict = getMethodCodesizeDictFromReachabilityJson(reachabilityData)
                codesizes = new Array(methodList.length)

                for(let i = 0; i < methodList.length; i++) {
                    codesizes[i] = codesizesDict[methodList[i]] ?? 0
                }


                for (const entry of entries) {
                    if(entry.filename === "reachability.json")
                    {
                        continue;
                    }

                    const zipFileWriter = new zip.Uint8ArrayWriter()
                    const data = await entry.getData(zipFileWriter)

                    let input_ptr = Module._malloc(data.length);
                    Module.HEAPU8.set(data, input_ptr);

                    filesAsByteArrays[entry.filename] = { data: input_ptr, length: data.length }
                }

                all_reachable_ptr = init(filesAsByteArrays["types.txt"].data, filesAsByteArrays["types.txt"].length,
                    filesAsByteArrays["methods.txt"].data, filesAsByteArrays["methods.txt"].length,
                    filesAsByteArrays["typeflows.txt"].data, filesAsByteArrays["typeflows.txt"].length,
                    filesAsByteArrays["typestates.bin"].data, filesAsByteArrays["typestates.bin"].length,
                    filesAsByteArrays["interflows.bin"].data, filesAsByteArrays["interflows.bin"].length,
                    filesAsByteArrays["direct_invokes.bin"].data, filesAsByteArrays["direct_invokes.bin"].length,
                    filesAsByteArrays["typeflow_methods.bin"].data, filesAsByteArrays["typeflow_methods.bin"].length,
                    filesAsByteArrays["typeflow_filters.bin"].data, filesAsByteArrays["typeflow_filters.bin"].length,
                    filesAsByteArrays["declaring_types.bin"].data, filesAsByteArrays["declaring_types.bin"].length,
                )

                for (const span of Object.values(filesAsByteArrays))
                    Module._free(span.data)

                reachable_under_selection_ptr = all_reachable_ptr
                prepareListView(generateHierarchyFromReachabilityJsonAndMethodList(reachabilityData, methodList))
            }
        }

        function allowDrop(ev) {
            ev.preventDefault();
        }

        function drop(ev) {
            if (ev.dataTransfer.files.length > 0) {
                ev.preventDefault()
                tryLoadFile(ev.dataTransfer.files[0])
            }
        }
    </script>

    <div id="fileselect-panel" class="fullscreen" ondragover="allowDrop(event)" ondrop="drop(event)">
        <input type="file" id="file-input" accept="application/zip" hidden>
        <div class="center">
            <big>Drop <button onClick="triggerFileSectionDialog()"><big>or select</big></button> Causality Export</big>
        </div>
    </div>

    <div id="loading-panel" class="fullscreen" hidden>
        <div class="center">
            <big>Causality Graph is being parsed...</big>
        </div>
    </div>

    <div id="main-panel" class="fullscreen" hidden>
        <div class="overview-div">
            <span><b>Cut Overview:</b></span>
            <div id="cut-overview-root"></div>
        </div>
        <div class="imageview-div">
            <span><b>In-Image Overview:</b></span>
            <div id="imageview-root"></div>
        </div>
        <div class="detail-div">
            <label for="Output_hoverpurge"></label><textarea placeholder="Events made unreachable" wrap="off" style="width: 100%; height: 100%" id="Output_hoverpurge" spellcheck="false" rows="50" readonly="readonly"></textarea>
        </div>
    </div>

    <script>
        class Trie {
            constructor(dict) {
                this.root = { next: {} }
                for (const str in dict) {
                    let node = this.root
                    for (const c of str) {
                        if (!node.next[c]) {
                            node.next[c] = { next: {} }
                        }
                        node = node.next[c]
                    }
                    node.val = dict[str]
                }
            }

            find(str) {
                let node = this.root
                let val = undefined
                for (const c of str) {
                    if (!node.next[c])
                        return val
                    node = node.next[c]
                    if (node.val)
                        val = node.val
                }
                return val
            }
        }
    </script>
    <script>
        let selectedForPurging = new Set()

        function generateHierarchyFromReachabilityJsonAndMethodList(json, cgNodes) {
            let dict = { children: [] }

            prefixToNode = {}

            for (const toplevel of json) {
                let l1name = "ϵ"
                let l1fullname = ""

                let display_path = toplevel.path
                if (display_path && display_path.endsWith(".jar")) {
                    let index = display_path.lastIndexOf("/")
                    if (index !== -1) {
                        display_path = display_path.substring(index+1)
                    }
                }

                if (toplevel.path && toplevel.module) {
                    l1name = display_path + ":" + toplevel.module
                    l1fullname = toplevel.path + ":" + toplevel.module
                } else if(toplevel.path) {
                    l1name = display_path
                    l1fullname = toplevel.path
                } else if(toplevel.module) {
                    l1name = toplevel.module
                    l1fullname = toplevel.module
                }

                let l1 = { children: [], name: l1name, fullname: l1fullname, cg_nodes: [] }
                if (toplevel.path) {
                    prefixToNode[toplevel.path] = l1
                }
                dict.children.push(l1)

                for (const packageName in toplevel.packages) {
                    const package = toplevel.packages[packageName]
                    let prefix = ""
                    let l2 = l1

                    if(packageName.length !== 0) {
                        for (const subPackageName of packageName.split('.')) {
                            prefix += subPackageName + "."
                            let next = l2.children.find(n => n.name === subPackageName)
                            if(!next) {
                                next = { children: [], fullname: prefix, name: subPackageName, cg_nodes: [] }

                                /* Eigentlich sollten keine Causality-Graph-Knoten direkt in einem Package hängen.
                                 * Es gibt jedoch Knoten für Klassen, die nicht reachable sind (z.B. Build-Time-Features).
                                 * Diese müssen unbedingt in die Abschneide-Berechnung miteinbezogen werden.
                                 * Idealerweise sollten sie auch in der Baumstruktur auftauchen.
                                 * Das ist aber gerade noch zu kompliziert umzusetzen... */
                                prefixToNode[prefix] = next

                                l2.children.push(next)
                            }
                            l2 = next
                        }
                    }

                    for (const typeName in package.types) {
                        const type = package.types[typeName]
                        let l3 = { children: [], fullname: prefix + typeName, name: typeName, cg_nodes: [] }
                        prefixToNode[l3.fullname] = l3
                        l2.children.push(l3)

                        for (const method in type.methods) {
                            let l4 = { fullname: l3.fullname + "." + method, name: method, cg_nodes: [] }
                            prefixToNode[l4.fullname] = l4
                            l3.children.push(l4)
                        }
                    }
                }
            }

            const trie = new Trie(prefixToNode)

            for (let i = 0; i < cgNodes.length; i++) {
                const cgNodeName = cgNodes[i]
                const node = trie.find(cgNodeName)
                if (node)
                    node.cg_nodes.push(i)
            }

            return dict
        }

        function formatByteSizesWithUnitPrefix(size) {
            if(size > 1000000)
                return (size / 1000000).toPrecision(3) + " MB"
            else if(size > 1000)
                return (size / 1000).toPrecision(3) + " KB"
            else
                return size.toPrecision(3) + " B"
        }

        function forEachInSubtree(node, callback) {
            let stack = []
            stack.push(node)
            while (stack.length > 0) {
                const u = stack.pop()
                if (u.children)
                    stack = stack.concat(u.children)
                callback(u)
            }
        }

        function collectCgNodesInSubtree(node) {
            let group = []
            forEachInSubtree(node, u => {
                if (u.cg_nodes)
                    group = group.concat(u.cg_nodes)
            })
            return group
        }

        function insertChildren(element, node) {
            let list = generateHTML(node)
            element.appendChild(list)
            recalculateCutOverview()
            //calculateAggregateCutWeight(list, node)
        }

        let maxRes

        function calculateAggregateCutWeight(list, node) {
            let purge_groups = node.children.map(collectCgNodesInSubtree)

            let res = Array(purge_groups.length)
            for (let i = 0; i < purge_groups.length; i++) {
                res[i] = 0
            }

            // The C++ code doesn't handle empty groups well. Therefore we already handle them here.
            let purge_root = { children: purge_groups.map((g, i) => { return { mids: g, index: i } }).filter(n => n.mids.length > 0) }

            // Optimization for special case where we only want a single purge
            if (purge_root.children.length === 1) {
                purge_root = purge_root.children[0]
            }

            nonempty_res = simulatePurgesBatched(purge_root, (node, size) => {
                if (node.index !== undefined)
                    res[node.index] = size
            })

            if (node === this.dataRoot)
                this.maxRes = Math.max(...res)

            assert(this.maxRes)

            for (let i = 0; i < list.children.length; i++) {
                list.children[i].querySelector('.cut-size-column').textContent = formatByteSizesWithUnitPrefix(res[i])
                list.children[i].querySelector('.cut-size-bar').style.width = (res[i] / this.maxRes * 100) + "%"
            }

            let order = new Array(list.children.length)
            for(let i = 0; i < order.length; i++)
                order[i] = i

            let nodes = list.children
            order.sort((a, b) => res[b] - res[a]).map(i => nodes[i]).forEach(node => list.appendChild(node))
        }

        function expandClickHandler(element, node, populateCallback) {
            let expanded = element.classList.toggle("caret-down");

            if(!element.parentElement.querySelector(".nested") && expanded) {
                populateCallback()
            }

            element.parentElement.querySelector(".nested").classList.toggle("active");
        }

        function generateHTML(data) {
            let ul = document.createElement("ul")
            ul.className = "nested"

            for(const d of data.children) {
                let li = document.createElement("li")
                li.className = "cut-row"
                d.html = li
                ul.appendChild(li)

                let out = document.createElement("span")
                out.className = "cut-size-column"
                li.appendChild(out)

                let sizebar = document.createElement("div")
                sizebar.className = "cut-size-bar"
                li.appendChild(sizebar)

                let node = d
                let span = document.createElement("span")
                span.className = "caret"
                if (d.children) {
                    span.addEventListener("click", () => {
                        expandClickHandler(span, node, () => insertChildren(li, node));
                    });
                } else {
                    span.style.visibility = "hidden"
                }
                li.appendChild(span)

                let nameSpan = document.createElement("span")
                nameSpan.appendChild(document.createTextNode(d.name))
                nameSpan.title = d.fullname
                nameSpan.className = "node-text"
                li.appendChild(nameSpan)

                nameSpan.addEventListener("click", () => {
                    let selected = nameSpan.classList.toggle("selected-for-purge")
                    if (selected)
                        selectedForPurging.add(node)
                    else
                        selectedForPurging.delete(node)
                    updatePurgeValues()
                })
            }

            return ul
        }

        let maxCodeSize

        function generateHtmlImageview(data) {
            let ul = document.createElement("ul")
            ul.className = "nested"

            for (const d of data.children) {
                let codesize = 0
                forEachInSubtree(d, (v) => {
                    if (v.cg_nodes)
                        for (const i of v.cg_nodes)
                            codesize += codesizes[i]
                })
                d.size = codesize
            }

            if (data === this.dataRoot) {
                maxCodeSize = Math.max(...data.children.map(d => d.size))
            }

            assert(maxCodeSize)

            for(const d of data.children) {
                let li = document.createElement("li")
                li.className = "image-row"
                d.html_imageview = li
                ul.appendChild(li)
                let span = document.createElement("span")
                li.appendChild(span)

                let out3 = document.createElement("span")
                out3.className = "total-size-column"
                out3.textContent = formatByteSizesWithUnitPrefix(d.size)
                li.appendChild(out3)

                let out4 = document.createElement("div")
                out4.className = "size-bar-outer"
                out4.style.width = (d.size / maxCodeSize * 100) + "%"
                li.appendChild(out4)

                let out5 = document.createElement("div")
                out5.className = "size-bar-inner"
                out4.appendChild(out5)

                let out2 = document.createElement("span")
                out2.className = "size-bar-text"
                li.appendChild(out2)

                let node = d
                span.className = "caret"
                if (d.children) {
                    span.addEventListener("click", () => {
                        expandClickHandler(span, node, () => li.appendChild(generateHtmlImageview(node)));
                    });
                } else {
                    span.style.visibility = "hidden"
                }
                li.appendChild(span)

                let nameSpan = document.createElement("span")
                nameSpan.appendChild(document.createTextNode(d.name))
                nameSpan.title = d.fullname
                nameSpan.className = "node-text"
                li.appendChild(nameSpan)

                refreshPurgeValueForImageviewNode(d)
            }

            let child_sizes = data.children.map(cn => cn.size)

            let order = new Array(data.children.length)
            for(let i = 0; i < order.length; i++)
                order[i] = i

            let nodes = ul.children
            order.sort((a, b) => child_sizes[b] - child_sizes[a]).map(i => nodes[i]).forEach(node => ul.appendChild(node))

            return ul
        }

        function prepareListView(data) {
            this.dataRoot = data
            {
                const rootTreeViewElement = document.getElementById("cut-overview-root")
                insertChildren(rootTreeViewElement, data)
                const list = rootTreeViewElement.querySelector('ul')
                list.classList.remove("nested")
                list.classList.add("unpadded")
                list.classList.add("active")
            }
            {
                const rootTreeViewElement = document.getElementById("imageview-root")
                const list = generateHtmlImageview(data)
                rootTreeViewElement.appendChild(list)
                list.classList.remove("nested")
                list.classList.add("unpadded")
                list.classList.add("active")
            }
        }

        let reachable_under_selection_ptr

        function createPurgeNodeTree(node) {
            let root = { src: node }

            let mids = []
            if (node.cg_nodes)
                mids = node.cg_nodes

            let children = []
            if (node.children) {
                for(const child of node.children) {
                    if (selectedForPurging.has(child))
                        continue;
                    if (child.html) {
                        const child_root = createPurgeNodeTree(child)
                        if (child_root)
                            children.push(child_root)
                    } else {
                        mids = mids.concat(collectCgNodesInSubtree(child))
                    }
                }
            }

            if (children.length === 0 && mids.length === 0)
                return undefined

            if (mids.length !== 0)
                root.mids = mids

            if (children.length !== 0)
                root.children = children

            return root
        }

        function recalculateCutOverview() {
            const purgeNodeTreeRoot = createPurgeNodeTree(this.dataRoot)

            let maxPurgedSize = 0

            simulatePurgesBatched(purgeNodeTreeRoot, (node, purgedSize) => {
                node.purgedSize = purgedSize
                maxPurgedSize = Math.max(maxPurgedSize, purgedSize)
            })

            forEachInSubtree(purgeNodeTreeRoot, u => {
                const html = u.src.html
                if (!html)
                    return

                html.querySelector('.cut-size-column').textContent = formatByteSizesWithUnitPrefix(u.purgedSize)
                html.querySelector('.cut-size-bar').style.width = (u.purgedSize / maxPurgedSize * 100) + "%"
            })
        }

        function updatePurgeValues() {
            reachable_under_selection_ptr = simulatePurge([...new Set([...selectedForPurging].flatMap(collectCgNodesInSubtree))])

            forEachInSubtree(this.dataRoot, (u) => {
                if (u.html_imageview) {
                    refreshPurgeValueForImageviewNode(u)
                }
            })
        }

        function refreshPurgeValueForImageviewNode(u) {
            const all_reachable = Module.HEAPU8.subarray(all_reachable_ptr, all_reachable_ptr + codesizes.length)
            const reachable_under_selection = Module.HEAPU8.subarray(reachable_under_selection_ptr, reachable_under_selection_ptr + codesizes.length)

            let purgedCodesize = 0
            forEachInSubtree(u, (v) => {
                if (v.cg_nodes)
                    for (const i of v.cg_nodes)
                        if (all_reachable[i] !== 0xFF && reachable_under_selection[i] === 0xFF)
                            purgedCodesize += codesizes[i]
            })
            let purgedPercentage = 100 * purgedCodesize / u.size
            let barWidth = 0
            let percentageText = ""
            if (u.size !== 0) {
                barWidth = purgedPercentage.toFixed(1) + "%"
                percentageText = purgedPercentage === 0 ? "" : purgedPercentage.toFixed(1) + " %"
            }
            u.html_imageview.querySelector(".size-bar-text").textContent = percentageText
            u.html_imageview.querySelector(".size-bar-inner").style.width = barWidth
        }
    </script>
</body>
</html>

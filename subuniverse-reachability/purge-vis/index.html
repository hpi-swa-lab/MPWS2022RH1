<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Causality Graph Text Interface</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <script src="lib/causality_graph.js"></script>
    <script src="zip.min.js"></script>
    <script>
        let simulate_purge = Module.cwrap("simulate_purge", "number", ["number", "number"]);
        let simulate_purges_batched = Module.cwrap("simulate_purges_batched", "number", ["number", "number"])
        let show_reachability = Module.cwrap("show_reachability", "number", ["number"]);
        let init = Module.cwrap("init", "number", ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
        let get_reachability_hyperpath = Module.cwrap("get_reachability_hyperpath", "number", ["number"])


        let all_reachable_ptr

        function simulatePurge(purge_group) {
            let midsPtr = Module._malloc(purge_group.length * 4)
            let midsArray = Module.HEAPU32.subarray(midsPtr / 4, midsPtr / 4 + purge_group.length)

            for (let i = 0; i < purge_group.length; i++)
                midsArray[i] = purge_group[i] + 1

            let method_history_ptr = simulate_purge(midsPtr, purge_group.length)
            // dealloc memory
            Module._free(midsPtr);

            return Module.HEAPU8.slice(method_history_ptr, method_history_ptr + codesizes.length)
        }

        function calcPurgeNodesCount(purge_root) {
            let cnt = 1
            if(purge_root.mids && purge_root.children)
                cnt++
            if(purge_root.children)
                for(const child of purge_root.children)
                    cnt += calcPurgeNodesCount(child)
            return cnt
        }

        function calcMidsCount(purge_root) {
            let cnt = 0
            if(purge_root.mids)
                cnt += purge_root.mids.length
            if(purge_root.children)
                for(const child of purge_root.children)
                    cnt += calcMidsCount(child)
            return cnt
        }

        function simulatePurgesBatched(purge_root, resultCallback, prepurgeMids = []) {
            const prepurgeMidsSet = new Set(prepurgeMids)

            const overlap = purge_root.children.flatMap(c => c.mids).some(mid => prepurgeMidsSet.has(mid))


            let purgeNodesCount = calcPurgeNodesCount(purge_root)

            let subsetsArrLen = (purgeNodesCount) * 4 /* {{ptr, len}, {child_ptr, child_len}} */
            let subsetsArrPtr = Module._malloc(subsetsArrLen * 4 /* (4 byte ptr/len) */)
            let subsetsArr = Module.HEAPU32.subarray(subsetsArrPtr / 4, subsetsArrPtr / 4 + subsetsArrLen)

            let midsCount = calcMidsCount(purge_root) + prepurgeMids.length

            let midsPtr = Module._malloc(midsCount * 4)
            let midsPos = midsPtr / 4

            let indexToInputNode = Array(purgeNodesCount)
            {
                let i = 1

                function layoutChildren(purge_root, offset) {
                    indexToInputNode[offset] = purge_root
                    const midsPos_start = midsPos

                    const i_start = i

                    if (purge_root.mids) {
                        if (purge_root.children) {
                            subsetsArr[i*4] /* ptr */ = midsPos * 4
                            subsetsArr[i*4 + 1] /* len */ = purge_root.mids.length
                            subsetsArr[i*4 + 2] = 0 // no children
                            subsetsArr[i*4 + 3] = 0 // no children
                            i++
                        }
                        for(const mid of purge_root.mids)
                            Module.HEAPU32[midsPos++] = mid + 1
                    }

                    let i_end = i

                    if (purge_root.children) {
                        let local_i = i
                        i += purge_root.children.length
                        i_end = i
                        for (const child of purge_root.children) {
                            layoutChildren(child, local_i)
                            local_i++
                        }
                    }

                    const midsPos_end = midsPos

                    const slice = subsetsArr.subarray(offset*4, (offset+1)*4)
                    slice[0] = midsPos_start * 4
                    slice[1] = midsPos_end - midsPos_start
                    slice[2] = subsetsArrPtr + i_start * 16
                    slice[3] = i_end - i_start
                }

                for (const mid of prepurgeMids)
                    Module.HEAPU32[midsPos++] = mid + 1
                layoutChildren(purge_root, 0)
                // Also include prepurgeMids
                subsetsArr[0] = midsPtr
                subsetsArr[1] += prepurgeMids.length
            }
            assert(midsPos * 4 === midsPtr + midsCount * 4)

            const callback = (iteration, method_history_ptr) => {
                const inputNode = indexToInputNode[iteration]
                if (!inputNode)
                    return;
                const still_reachable = Module.HEAPU8.subarray(method_history_ptr, method_history_ptr + codesizes.length)
                resultCallback(inputNode, still_reachable)
                return 0
            }

            const callback_ptr = addFunction(callback, 'iii')
            const status = simulate_purges_batched(subsetsArrPtr, callback_ptr)
            removeFunction(callback_ptr)

            Module._free(subsetsArrPtr)
            Module._free(midsPtr)

            if(status === 0)
                throw new Error("simulate_purges_batched exited with error code " + status)
        }

        function printReachability(str){
            let ptr  = allocateUTF8(str)

            let retPtr = show_reachability(ptr)

            document.getElementById("Output_reachability").value = UTF8ToString(retPtr)

            // dealloc memory
            Module._free(ptr);
            Module._free(retPtr);
        }

        function getReachabilityHyperpath(mid) {
            const edgeBufPtr = get_reachability_hyperpath(mid+1)
            const edgeBufU32index = edgeBufPtr / Module.HEAPU32.BYTES_PER_ELEMENT
            const len = Module.HEAPU32.at(edgeBufU32index)
            const arr = Module.HEAPU32.subarray(edgeBufU32index + 1, edgeBufU32index + 1 + 2 * len)

            let edges = Array(len)

            for(let i = 0; i < edges.length; i++)
                edges[i] = { src: arr[i*2] - 1, dst: arr[i*2+1] - 1 }

            Module._free(edgeBufPtr)

            return edges
        }

        const model = (() => {

            return {
                getEntries(file, options) {
                    return (new zip.ZipReader(new zip.BlobReader(file))).getEntries(options);
                },
                async getURL(entry, options) {
                    return URL.createObjectURL(await entry.getData(new zip.BlobWriter(), options));
                }
            };

        })();

        function triggerFileSectionDialog() {
            let fileInput = document.getElementById("file-input");
            fileInput.dispatchEvent(new MouseEvent("click"));
            fileInput.onchange = selectFile;
        }

        function selectFile() {
            const fileInput = document.getElementById("file-input");
            if (fileInput.files.length > 0) {
                tryLoadFile(fileInput.files[0])
            }
        }

        async function tryLoadFile(file) {
            try {
                document.getElementById("fileselect-panel").hidden = true
                document.getElementById("loading-panel").hidden = false
                await loadFiles(file, "utf-8");
                document.getElementById("loading-panel").hidden = true
                document.getElementById("main-panel").hidden = false
            } catch (error) {
                alert(error);
                document.getElementById("loading-panel").hidden = true
                document.getElementById("fileselect-panel").hidden = false
            }

            prepareListView(this.dataRoot)
        }

        function getMethodCodesizeDictFromReachabilityJson(data) {
            let dict = {}

            for (const toplevel of data) {
                for (const packageName in toplevel.packages) {
                    const package = toplevel.packages[packageName]
                    for (const typeName in package.types) {
                        const type = package.types[typeName]
                        for (const methodName in type.methods) {
                            const method = type.methods[methodName]
                            const fullyQualifiedName = `${packageName}.${typeName}.${methodName}`
                            dict[fullyQualifiedName] = method.size
                        }
                    }
                }
            }

            return dict
        }

        async function loadFiles(selectedFile, filenameEncoding) {
            let entries = await model.getEntries(selectedFile, { filenameEncoding });
            if (entries && entries.length) {
                filesAsByteArrays = {}

                let reachabilityData = JSON.parse(await entries.find(e => e.filename === "reachability.json").getData(new zip.TextWriter()))
                let methods = await entries.find(e => e.filename === "methods.txt").getData(new zip.TextWriter())
                methodList = methods.split('\n')
                if(methodList[methodList.length-1].length === 0) {
                    methodList.pop()
                }
                let codesizesDict = getMethodCodesizeDictFromReachabilityJson(reachabilityData)
                codesizes = new Array(methodList.length)

                for(let i = 0; i < methodList.length; i++) {
                    codesizes[i] = codesizesDict[methodList[i]] ?? 0
                }


                for (const entry of entries) {
                    if(entry.filename === "reachability.json")
                    {
                        continue;
                    }

                    const zipFileWriter = new zip.Uint8ArrayWriter()
                    const data = await entry.getData(zipFileWriter)

                    let input_ptr = Module._malloc(data.length);
                    Module.HEAPU8.set(data, input_ptr);

                    filesAsByteArrays[entry.filename] = { data: input_ptr, length: data.length }
                }

                all_reachable_ptr = init(filesAsByteArrays["types.txt"].data, filesAsByteArrays["types.txt"].length,
                    filesAsByteArrays["methods.txt"].data, filesAsByteArrays["methods.txt"].length,
                    filesAsByteArrays["typeflows.txt"].data, filesAsByteArrays["typeflows.txt"].length,
                    filesAsByteArrays["typestates.bin"].data, filesAsByteArrays["typestates.bin"].length,
                    filesAsByteArrays["interflows.bin"].data, filesAsByteArrays["interflows.bin"].length,
                    filesAsByteArrays["direct_invokes.bin"].data, filesAsByteArrays["direct_invokes.bin"].length,
                    filesAsByteArrays["typeflow_methods.bin"].data, filesAsByteArrays["typeflow_methods.bin"].length,
                    filesAsByteArrays["typeflow_filters.bin"].data, filesAsByteArrays["typeflow_filters.bin"].length,
                    filesAsByteArrays["declaring_types.bin"].data, filesAsByteArrays["declaring_types.bin"].length,
                )

                for (const span of Object.values(filesAsByteArrays))
                    Module._free(span.data)

                reachable_under_selection = Module.HEAPU8.slice(all_reachable_ptr, all_reachable_ptr + codesizes.length)
                reachable_in_image_view = reachable_under_selection
                this.dataRoot = generateHierarchyFromReachabilityJsonAndMethodList(reachabilityData, methodList)
            }
        }

        function allowDrop(ev) {
            ev.preventDefault();
        }

        function drop(ev) {
            if (ev.dataTransfer.files.length > 0) {
                ev.preventDefault()
                tryLoadFile(ev.dataTransfer.files[0])
            }
        }
    </script>

    <div id="fileselect-panel" class="fullscreen" ondragover="allowDrop(event)" ondrop="drop(event)">
        <input type="file" id="file-input" accept="application/zip" hidden>
        <div class="center">
            <big>Drop <button onClick="triggerFileSectionDialog()"><big>or select</big></button> Causality Export</big>
        </div>
    </div>

    <div id="loading-panel" class="fullscreen" hidden>
        <div class="center">
            <big>Causality Graph is being parsed...</big>
        </div>
    </div>

    <div id="main-panel" class="fullscreen" hidden>
        <div class="overview-div">
            <span><b>Cut Overview:</b></span>
            <label>
                <input type="checkbox" checked="true">
                Preview cutoffs
            </label>
            <div id="cut-overview-root"></div>
        </div>
        <div class="imageview-div">
            <span><b>In-Image Overview:</b></span>
            <div id="imageview-root"></div>
        </div>
        <div class="detail-div">
            <svg width="100%" height="100%" viewBox="0 0 800 800">
                <marker id="arrowhead" markerWidth="10" markerHeight="7"
                        refX="10" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" />
                </marker>

                <g id="chartpanel">
                    <rect id="zoom-opfer" fill="black" opacity="0" height="600" width="1200"></rect>
                    <g id="chart"></g>
                </g>
            </svg>
        </div>
    </div>

    <script src="https://d3js.org/d3.v5.min.js"></script>

    <script>
        class Trie {
            constructor(dict) {
                this.root = { next: {} }
                for (const str in dict) {
                    let node = this.root
                    for (const c of str) {
                        if (!node.next[c]) {
                            node.next[c] = { next: {} }
                        }
                        node = node.next[c]
                    }
                    node.val = dict[str]
                }
            }

            find(str) {
                let node = this.root
                let val = undefined
                for (const c of str) {
                    if (!node.next[c])
                        return val
                    node = node.next[c]
                    if (node.val)
                        val = node.val
                }
                return val
            }
        }
    </script>
    <script>
        let selectedForPurging = new Set()

        function generateHierarchyFromReachabilityJsonAndMethodList(json, cgNodes) {
            let dict = { children: [] }

            prefixToNode = {}

            for (const toplevel of json) {
                let l1name = "ϵ"
                let l1fullname = ""

                let display_path = toplevel.path
                if (display_path && display_path.endsWith(".jar")) {
                    let index = display_path.lastIndexOf("/")
                    if (index !== -1) {
                        display_path = display_path.substring(index+1)
                    }
                }

                if (toplevel.path && toplevel.module) {
                    l1name = display_path + ":" + toplevel.module
                    l1fullname = toplevel.path + ":" + toplevel.module
                } else if(toplevel.path) {
                    l1name = display_path
                    l1fullname = toplevel.path
                } else if(toplevel.module) {
                    l1name = toplevel.module
                    l1fullname = toplevel.module
                }

                let l1 = { children: [], name: l1name, fullname: l1fullname, cg_nodes: [] }
                if (toplevel.path) {
                    prefixToNode[toplevel.path] = l1
                }
                dict.children.push(l1)

                for (const packageName in toplevel.packages) {
                    const package = toplevel.packages[packageName]
                    let prefix = ""
                    let l2 = l1

                    if(packageName.length !== 0) {
                        for (const subPackageName of packageName.split('.')) {
                            prefix += subPackageName + "."
                            let next = l2.children.find(n => n.name === subPackageName)
                            if(!next) {
                                next = { children: [], fullname: prefix, name: subPackageName, cg_nodes: [] }

                                /* Eigentlich sollten keine Causality-Graph-Knoten direkt in einem Package hängen.
                                 * Es gibt jedoch Knoten für Klassen, die nicht reachable sind (z.B. Build-Time-Features).
                                 * Diese müssen unbedingt in die Abschneide-Berechnung miteinbezogen werden.
                                 * Idealerweise sollten sie auch in der Baumstruktur auftauchen.
                                 * Das ist aber gerade noch zu kompliziert umzusetzen... */
                                prefixToNode[prefix] = next

                                l2.children.push(next)
                            }
                            l2 = next
                        }
                    }

                    for (const typeName in package.types) {
                        const type = package.types[typeName]
                        let l3 = { children: [], fullname: prefix + typeName, name: typeName, cg_nodes: [] }
                        prefixToNode[l3.fullname] = l3
                        l2.children.push(l3)

                        for (const method in type.methods) {
                            let l4 = { fullname: l3.fullname + "." + method, name: method, cg_nodes: [] }
                            prefixToNode[l4.fullname] = l4
                            l3.children.push(l4)
                        }
                    }
                }
            }

            const trie = new Trie(prefixToNode)

            for (let i = 0; i < cgNodes.length; i++) {
                const cgNodeName = cgNodes[i]
                const node = trie.find(cgNodeName)
                if (node)
                    node.cg_nodes.push(i)
            }

            return dict
        }

        function formatByteSizesWithUnitPrefix(size) {
            if(size > 1000000)
                return (size / 1000000).toPrecision(3) + " MB"
            else if(size > 1000)
                return (size / 1000).toPrecision(3) + " KB"
            else
                return size.toPrecision(3) + " B"
        }

        function forEachInSubtree(node, callback) {
            let stack = []
            stack.push(node)
            while (stack.length > 0) {
                const u = stack.pop()
                if (u.children)
                    stack = stack.concat(u.children)
                callback(u)
            }
        }

        function collectCgNodesInSubtree(node) {
            let group = []
            forEachInSubtree(node, u => {
                if (u.cg_nodes)
                    group = group.concat(u.cg_nodes)
            })
            return group
        }

        function insertChildren(element, node) {
            let list = generateHTML(node)
            element.appendChild(list)
            //recalculateCutOverview()
            recalculateCutOverviewForSubtree(list, node)
        }

        function expandClickHandler(element, node, populateCallback) {
            let expanded = element.classList.toggle("caret-down");

            if(!element.parentElement.querySelector(".nested") && expanded) {
                populateCallback()
            }

            element.parentElement.querySelector(".nested").classList.toggle("active");
        }

        function generateHTML(data) {
            let ul = document.createElement("ul")
            ul.className = "nested"

            for(const d of data.children) {
                let li = document.createElement("li")
                li.className = "cut-row"
                d.html = li
                ul.appendChild(li)

                let out = document.createElement("span")
                out.className = "cut-size-column"
                li.appendChild(out)

                let sizebar = document.createElement("div")
                sizebar.className = "cut-size-bar"
                li.appendChild(sizebar)

                let node = d
                let span = document.createElement("span")
                span.className = "caret"
                if (d.children) {
                    span.addEventListener("click", () => {
                        expandClickHandler(span, node, () => insertChildren(li, node));
                    });
                } else {
                    span.style.visibility = "hidden"
                }
                li.appendChild(span)

                let nameSpan = document.createElement("span")
                nameSpan.appendChild(document.createTextNode(d.name))
                //nameSpan.title = d.fullname
                nameSpan.className = "node-text"
                li.appendChild(nameSpan)

                nameSpan.addEventListener("mouseenter", async () => {
                    nameSpan.classList.add("hovered-for-purge")

                    if(selectedForPurging.has(node))
                        return;

                    reachable_in_image_view = node.still_reachable
                    updatePurgeValues()
                })

                nameSpan.addEventListener("mouseleave", async () => {
                    nameSpan.classList.remove("hovered-for-purge")

                    if(selectedForPurging.has(node))
                        return;
                    reachable_in_image_view = reachable_under_selection
                    updatePurgeValues()
                })

                nameSpan.addEventListener("click", async () =>  {
                    nameSpan.classList.remove("hovered-for-purge")
                    let selected = nameSpan.classList.toggle("selected-for-purge")
                    if (selected) {
                        selectedForPurging.add(node)
                        reachable_in_image_view = reachable_under_selection = node.still_reachable
                    }
                    else {
                        selectedForPurging.delete(node)
                        reachable_in_image_view = reachable_under_selection = simulatePurge([...new Set([...selectedForPurging].flatMap(collectCgNodesInSubtree))])
                    }

                    updatePurgeValues()

                    await new Promise(resolve => setTimeout(resolve, 0))
                    recalculateCutOverview()
                })
            }

            return ul
        }

        let maxCodeSize

        function generateHtmlImageview(data) {
            let ul = document.createElement("ul")
            ul.className = "nested"

            for (const d of data.children) {
                let codesize = 0
                forEachInSubtree(d, (v) => {
                    if (v.cg_nodes)
                        for (const i of v.cg_nodes)
                            codesize += codesizes[i]
                })
                d.size = codesize
            }

            if (data === this.dataRoot) {
                maxCodeSize = Math.max(...data.children.map(d => d.size))
            }

            assert(maxCodeSize)

            for(const d of data.children) {
                let li = document.createElement("li")
                li.className = "image-row"
                d.html_imageview = li
                ul.appendChild(li)
                let span = document.createElement("span")
                li.appendChild(span)

                let out3 = document.createElement("span")
                out3.className = "total-size-column"
                out3.textContent = formatByteSizesWithUnitPrefix(d.size)
                li.appendChild(out3)

                let out4 = document.createElement("div")
                out4.className = "size-bar-outer"
                out4.style.width = (d.size / maxCodeSize * 100) + "%"
                li.appendChild(out4)

                let out5 = document.createElement("div")
                out5.className = "size-bar-inner"
                out4.appendChild(out5)

                let out2 = document.createElement("span")
                out2.className = "size-bar-text"
                li.appendChild(out2)

                let node = d
                span.className = "caret"
                if (d.children) {
                    span.addEventListener("click", () => {
                        expandClickHandler(span, node, () => li.appendChild(generateHtmlImageview(node)));
                    });
                } else {
                    span.style.visibility = "hidden"
                }
                li.appendChild(span)

                let nameSpan = document.createElement("span")
                nameSpan.appendChild(document.createTextNode(d.name))
                //nameSpan.title = d.fullname
                nameSpan.className = "node-text"
                li.appendChild(nameSpan)

                nameSpan.addEventListener("click", async () =>  {
                    const mid = node.cg_nodes[0]
                    if (!mid)
                        return

                    const edges = getReachabilityHyperpath(mid)
                    renderGraphOnDetailView(edges, mid)
                })
            }

            let child_sizes = data.children.map(cn => cn.size)

            let order = new Array(data.children.length)
            for(let i = 0; i < order.length; i++)
                order[i] = i

            let nodes = ul.children
            order.sort((a, b) => child_sizes[b] - child_sizes[a]).map(i => nodes[i]).forEach(node => ul.appendChild(node))

            return ul
        }

        function prepareListView(data) {
            {
                const rootTreeViewElement = document.getElementById("cut-overview-root")
                insertChildren(rootTreeViewElement, data)
                const list = rootTreeViewElement.querySelector('ul')
                list.classList.remove("nested")
                list.classList.add("unpadded")
                list.classList.add("active")
            }
            {
                const rootTreeViewElement = document.getElementById("imageview-root")
                const list = generateHtmlImageview(data)
                rootTreeViewElement.appendChild(list)
                list.classList.remove("nested")
                list.classList.add("unpadded")
                list.classList.add("active")
            }
        }

        let reachable_under_selection
        let reachable_in_image_view // Also has the purges of current hover

        function createPurgeNodeTree(node) {
            let root = { src: node }

            let mids = []
            if (node.cg_nodes)
                mids = node.cg_nodes

            let children = []
            if (node.children) {
                for(const child of node.children) {
                    if (selectedForPurging.has(child))
                        continue;
                    if (child.html) {
                        const child_root = createPurgeNodeTree(child)
                        if (child_root)
                            children.push(child_root)
                    } else {
                        mids = mids.concat(collectCgNodesInSubtree(child))
                    }
                }
            }

            if (children.length === 0 && mids.length === 0)
                return undefined

            if (mids.length !== 0)
                root.mids = mids

            if (children.length !== 0)
                root.children = children

            return root
        }

        let maxPurgedSize

        function recalculateCutOverview() {
            for (const node of [...selectedForPurging]) {
                node.still_reachable = reachable_under_selection
                node.purgedSize = 0
            }

            const purgeNodeTreeRoot = createPurgeNodeTree(this.dataRoot)

            let maxPurgedSize = 0

            simulatePurgesBatched(purgeNodeTreeRoot, (node, still_reachable) => {
                node.src.still_reachable = still_reachable.slice()
                let purgedSize = 0
                for (let i = 0; i < codesizes.length; i++)
                    if (reachable_under_selection[i] !== 0xFF && still_reachable[i] === 0xFF)
                        purgedSize += codesizes[i]

                node.src.purgedSize = purgedSize
                maxPurgedSize = Math.max(maxPurgedSize, purgedSize)
            }, [...new Set([...selectedForPurging].flatMap(collectCgNodesInSubtree))])

            if(selectedForPurging.size === 0) {
                this.maxPurgedSize = maxPurgedSize
            }

            forEachInSubtree(this.dataRoot, u => {
                const html = u.html
                if (!html)
                    return
                if (u.purgedSize === undefined)
                    return

                html.querySelector('.cut-size-column').textContent = formatByteSizesWithUnitPrefix(u.purgedSize)
                html.querySelector('.cut-size-bar').style.width = (u.purgedSize / this.maxPurgedSize * 100) + "%"
            })

            /* sorting...
            forEachInSubtree(this.dataRoot, u => {
                if(!u.children)
                    return

                let list
                if(u === this.dataRoot) {
                    list = document.getElementById("cut-overview-root").children[0]
                } else if (!u.html) {
                    return
                } else {
                    list = u.html.querySelector("ul")
                }

                const nodes = u.children
                nodes.sort((a, b) => b.purgedSize - a.purgedSize).map(n => n.html).filter(node => node).forEach(node => list.appendChild(node))
            })
             */
        }

        function recalculateCutOverviewForSubtree(list, node) {
            let res = Array(node.children.length)
            for (let i = 0; i < node.children.length; i++) {
                res[i] = 0
            }

            // The C++ code doesn't handle empty groups well. Therefore we already handle them here.
            let purge_root = { children: node.children.map((c, i) => { return { mids: collectCgNodesInSubtree(c), index: i, src: c } }).filter(n => n.mids.length > 0) }

            simulatePurgesBatched(purge_root, (node, still_reachable) => {
                if(!node.src)
                    return;

                node.src.still_reachable = still_reachable.slice()

                let purgedSize = 0
                for (let i = 0; i < codesizes.length; i++)
                    if (reachable_under_selection[i] !== 0xFF && still_reachable[i] === 0xFF)
                        purgedSize += codesizes[i]

                res[node.index] = purgedSize
            }, [...new Set([...selectedForPurging].flatMap(collectCgNodesInSubtree))])

            if (node === this.dataRoot)
                this.maxPurgedSize = Math.max(...res)

            assert(this.maxPurgedSize)

            for (let i = 0; i < list.children.length; i++) {
                list.children[i].querySelector('.cut-size-column').textContent = formatByteSizesWithUnitPrefix(res[i])
                list.children[i].querySelector('.cut-size-bar').style.width = (res[i] / this.maxPurgedSize * 100) + "%"
            }

            let order = new Array(list.children.length)
            for(let i = 0; i < order.length; i++)
                order[i] = i

            let nodes = list.children
            order.sort((a, b) => res[b] - res[a]).map(i => nodes[i]).forEach(node => list.appendChild(node))
        }

        function updatePurgeValues() {
            forEachInSubtree(this.dataRoot, (u) => {
                if (u.html_imageview) {
                    refreshPurgeValueForImageviewNode(u)
                }
            })
        }

        function refreshPurgeValueForImageviewNode(u) {
            const all_reachable = Module.HEAPU8.subarray(all_reachable_ptr, all_reachable_ptr + codesizes.length)
            const still_reachable = reachable_in_image_view ?? all_reachable

            let purgedCodesize = 0
            forEachInSubtree(u, (v) => {
                if (v.cg_nodes)
                    for (const i of v.cg_nodes)
                        if (all_reachable[i] !== 0xFF && still_reachable[i] === 0xFF)
                            purgedCodesize += codesizes[i]
            })
            let purgedPercentage = 100 * purgedCodesize / u.size
            let barWidth = 0
            let percentageText = ""
            if (u.size !== 0) {
                barWidth = purgedPercentage.toFixed(1) + "%"
                percentageText = purgedPercentage === 0 ? "" : purgedPercentage.toFixed(1) + " %"
            }
            u.html_imageview.querySelector(".size-bar-text").textContent = percentageText
            u.html_imageview.querySelector(".size-bar-inner").style.width = barWidth
        }

        function renderGraphOnDetailView(edges, targetMid) {
            // Layout-Konstanten:
            const width = 800;
            const height = 800;
            const x0 = 0;
            const x1 = width;
            const y0 = 0;
            const y1 = height;

            const htmlSvg = document.getElementById("chart")
            htmlSvg.textContent = ""

            const svg = d3.select("#chart");

            // Graph construction
            graph = {nodes: new Set(), links: []};

            edges.forEach(function (e) {
                graph.nodes.add(e.src);
                graph.nodes.add(e.dst);
                graph.links.push({ source: e.src, target: e.dst });
            });

            graph.nodes = [...graph.nodes]

            // Modeling adjacency through indices
            graph.links.forEach(function (d, i) {
                graph.links[i].source = graph.nodes.indexOf(graph.links[i].source);
                graph.links[i].target = graph.nodes.indexOf(graph.links[i].target);
            });

            // Store index at each node
            graph.nodes.forEach(function (d, i) {
                graph.nodes[i] = { index: i, mid: d, name: methodList[d] ?? "<root>", adj: [], in_deg: 0 };
            });

            graph.links.forEach(l => {
                graph.nodes[l.target].adj.push(l.source)
                graph.nodes[l.source].in_deg++
            })

            let order = []

            for(let v = 0; v < graph.nodes.length; v++)
                if(graph.nodes[v].in_deg === 0)
                    order.push(v)
            for(let i = 0; i < order.length; i++)
                for(const v of graph.nodes[order[i]].adj) {
                    graph.nodes[v].in_deg--
                    if(graph.nodes[v].in_deg === 0)
                        order.push(v)
                }

            order = order.reverse()

            let maxDepth = 0

            for(const u of order) {
                let depth = 0
                for(const v of graph.nodes[u].adj) {
                    if(graph.nodes[v].depth + 1 > depth)
                        depth = graph.nodes[v].depth + 1
                }
                graph.nodes[u].depth = depth
                if(depth > maxDepth)
                    maxDepth = depth
            }

            // Draw nodes
            const node = svg.append("g")
                .attr("id", "nodes")
                .selectAll("circle")
                .data(graph.nodes)
                .enter()
                .append("circle")
                .attr("class", "node")
                .attr("r", 10)
                .style("fill", "#FF0000");

            // Draw edges
            const link = svg.append("g")
                .attr("id", "links")
                .selectAll("line")
                .data(graph.links)
                .enter()
                .append("line")
                .style("stroke", "#080808")
                .style("opacity", 0.5)
                .style("stroke-width", 1)
                .attr("marker-end", "url(#arrowhead)");

            node
                .append("title")
                .text(d => d.name);

            const nodeTextG = svg.append("g")
                .attr("id", "labels");

            const nodeText = nodeTextG
                .selectAll("text")
                .data(graph.nodes)
                .enter()
                .append("text")
                .style("text-anchor", "middle")
                .style("pointer-events", "none")
                .style("font-size", "14px")
                .attr("dy", -4 - 10)
                .text(d => d.name);

            // Force simulation
            var simulation = d3.forceSimulation(graph.nodes)
                .force("link", d3.forceLink(graph.links).distance(0).strength(0.000001))
                .force("charge", d3.forceManyBody().strength(-1000))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("y", d3.forceY().y(d => ((maxDepth - d.depth) / maxDepth) * height))
                .force("x", d3.forceX().x(width / 2))
                .on("tick", () => onZoom({ x: 0, y: 0, k: 1}))

            function onZoom() {
                transform = d3.zoomTransform(d3.select("#chartpanel").node());

                function transX(num)
                {
                    return num * transform.k + transform.x;
                }

                function transY(num)
                {
                    return num * transform.k + transform.y;
                }

                link
                    .attr("x1", d => transX(d.source.x * 0.9 + d.target.x * 0.1))
                    .attr("y1", d => transY(d.source.y * 0.9 + d.target.y * 0.1))
                    .attr("x2", d => transX(d.target.x * 0.9 + d.source.x * 0.1))
                    .attr("y2", d => transY(d.target.y * 0.9 + d.source.y * 0.1));

                node
                    .attr("cx", d => transX(d.x))
                    .attr("cy", d => transY(d.y));

                nodeText
                    .attr("x", d => transX(d.x))
                    .attr("y", d => transY(d.y));
            }

            var zoom = d3.zoom().on("zoom", onZoom);
            d3.select("#chartpanel").call(zoom);
        }
    </script>
</body>
</html>

import HierarchyNode from './SharedInterfaces/HierarchyNode'
import CausalityNode from './Visualizations/ZoomableCausalityGraph/Interfaces/CausalityNode'
import { parse } from 'papaparse'
import CausalityEdge from './Visualizations/ZoomableCausalityGraph/Interfaces/CausalityEdge'

export function loadTextFile(file: File): Promise<string> {
    return new Promise((resolve, reject) => {
        const reader = new FileReader()

        reader.onload = (event) => {
            if (event.target == null) {
                reject('No target given')
            } else if (event.target.result == null) {
                reject('No target result given')
            } else {
                resolve(event.target.result.toString())
            }
        }
        reader.onerror = (event) => reject(event)

        reader.readAsText(file)
    })
}

export function loadCSVFile(file: File): Promise<unknown[]> {
    return new Promise((resolve, reject) => {
        parse(file, {
            worker: true,
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            complete: (result, file) => {
                resolve(result.data)
            },
            error: (error, file) => {
                reject(error)
            }
        })
    })
}

export function parseToPackageHierarchy(hierarchyString: string): HierarchyNode {
    const data: HierarchyNode = {
        id: 0,
        parent: null,
        name: 'root',
        fullPath: '',
        children: [],
        subTreeSize: 0
    }

    let counter: number = 1

    hierarchyString.split('\n').forEach((row: string) => {
        let currentChildren: HierarchyNode[] = data.children
        let parent = data

        let splittedRow = row.split('.')
        splittedRow.forEach((pathSegment: string, index: number) => {
            let child = currentChildren.find((child: HierarchyNode) => child.name === pathSegment)

            if (!child) {
                child = {
                    id: counter,
                    parent: parent,
                    name: pathSegment,
                    fullPath: splittedRow.slice(0, index + 1).join('.'),
                    children: [],
                    subTreeSize: 0
                }
                currentChildren.push(child)
                counter++
            }

            currentChildren = child.children
            parent = child
        })
    })

    _addSubTreeSizes(data)

    return data
}

function filterOutGeneratedCode(rows: string[]): string[] {
    // filters out any row that includes the substrings '.$' or '$$'
    // as these are elements generated by graal which we don't need for this visualization
    return rows.filter((row: string) => !row.match(/[\$\.]\$/))
}

function parseSubclassesToPackageNames(rows: string[]): string[] {
    // Classes within classes are denoted with a '$' but we want to handle them
    // just like the rest of the package hierarchy
    return rows.map((row: string) => row.replaceAll('$', '.'))
}

function getNodesById(methods: Record<string, any>[]): Record<number, CausalityNode> {
    const result: Record<number, CausalityNode> = {}

    methods = methods.filter((method: Record<string, any>) => {
        return !method.Type.match(/[\$\.]\$/)
    })

    methods.forEach((method: Record<string, any>) => {
        method.Display = method.Display.replaceAll('$', '.')
        method.Name = method.Name.replaceAll('$', '.')
        method.Return = method.Return.replaceAll('$', '.')
        method.Type = method.Type.replaceAll('$', '.')

        result[method.Id] = {
            display: method.Display,
            flags: method.Flags,
            id: method.Id,
            name: method.Name,
            parameters: method.Parameters,
            returnType: method.Return,
            type: method.Type,
            isEntryPoint: false,
            directEdges: [],
            virtualEdges: []
        }
    })

    return result
}

function parseEdges(edgesReport: Record<string, any>[]): CausalityEdge[] {
    const result: CausalityEdge[] = []

    edgesReport.forEach((edge: Record<string, any>) =>
        result.push({
            sourceId: edge.StartId,
            targetId: edge.EndId,
            bytecodeIndexes: edge.BytecodeIndexes.toString()
        })
    )

    return result
}

export function parseToCausalityGraph(
    entryPointReports: Record<string, any>[],
    methodReports: Record<string, any>[],
    directEdgesReport: Record<string, any>[],
    virtualEdgesReport: Record<string, any>[]
): Record<number, CausalityNode> {
    const nodesById = getNodesById(methodReports)
    const directEdges = parseEdges(directEdgesReport)
    const virtualEdges = parseEdges(virtualEdgesReport)

    entryPointReports.forEach((entryPoint: Record<string, number>) => {
        const node = nodesById[entryPoint.Id]
        if (node) {
            node.isEntryPoint = true
        }
    })

    directEdges.forEach((directEdge: CausalityEdge) => {
        const node = nodesById[directEdge.sourceId]
        if (node) {
            node.directEdges.push(directEdge)
        }
    })

    virtualEdges.forEach((virtualEdge: CausalityEdge) => {
        const node = nodesById[virtualEdge.sourceId]
        if (node) {
            node.virtualEdges.push(virtualEdge)
        }
    })

    return nodesById
}

export function parseToCleanedPackageHierarchy(hierarchyString: string): HierarchyNode {
    const data: HierarchyNode = {
        id: 0,
        parent: null,
        name: 'root',
        fullPath: '',
        children: [],
        subTreeSize: 0
    }

    let counter: number = 1

    let rows = hierarchyString.split('\n')
    rows = filterOutGeneratedCode(rows)
    rows = parseSubclassesToPackageNames(rows)

    rows.forEach((row: string) => {
        let currentChildren: HierarchyNode[] = data.children
        let parent = data

        let splittedRow = row.split('.')
        splittedRow.forEach((pathSegment: string, index: number) => {
            let child = currentChildren.find((child: HierarchyNode) => child.name === pathSegment)

            if (!child) {
                child = {
                    id: counter,
                    parent: parent,
                    name: pathSegment,
                    fullPath: splittedRow.slice(0, index + 1).join('.'),
                    children: [],
                    subTreeSize: 0
                }
                currentChildren.push(child)
                counter++
            }

            currentChildren = child.children
            parent = child
        })
    })

    _addSubTreeSizes(data)
    console.log(data)

    return data
}

function _addSubTreeSizes(startingPoint: HierarchyNode): void {
    if (startingPoint.children.length === 0) {
        startingPoint.subTreeSize = 0
    } else {
        startingPoint.children.forEach((child) => {
            _addSubTreeSizes(child)
        })

        startingPoint.subTreeSize = startingPoint.children.reduce(
            (sum: number, child: HierarchyNode) => sum + child.subTreeSize,
            1
        )
    }
}

export function extractLastHierarchyLevel(hierarchyString: string): string[] {
    const lastLevels: string[] = []

    hierarchyString.split('\n').forEach((row: string) => {
        if (!row.match(/[\$\.]\$/)) {
            row = row.replaceAll('$', '.')

            const splitRow: string[] = row.split('.')
            const lastLevel: string = splitRow[splitRow.length - 1]

            lastLevels.push(lastLevel)
        }
    })

    return lastLevels
}

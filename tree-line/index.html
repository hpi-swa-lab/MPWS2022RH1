<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Tree Line</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-hierarchy@3"></script>
    <link rel="stylesheet" href="styles.css">
    <style>
        body {
            margin: 0;
        }
    </style>
</head>
<body>
    <canvas id="treeline"></canvas>
    <script type="module">
        // A function that makes sure a value is within a range. For example,
        // `2.clamp(0, 5)` returns 2 because 2 is between 0 and 5, but
        // `3.clamp(4, 6)` returns 4.
        Number.prototype.clamp = function (min, max) {
            return Math.min(Math.max(this, min), max);
        }

        /// Parses the content of a `used_methods_...` file into a tree. Ignores
        /// generated classes and their children.
        // TODO: Use the common function after Luc's PR is merged.
        function parseUsedMethodsIntoTree(text) {
            const tree = { name: '', children: [] }
            for (const row of text.split('\n')) {
                if (row == '' || row.includes('$$')) continue
                let current = tree
                for (const pathSegment of row.split(/[.$]/)) {
                    let child = current.children.find((child) => child.name === pathSegment)
                    if (!child) {
                        child = { name: pathSegment, children: [] }
                        current.children.push(child)
                    }
                    current = child
                }
            }
            return tree
        }

        /// Adds a `size` attribute in each node that corresponds to the total
        /// size of that subtree including its children. For now, we just assume
        /// that each method has a size of 1.
        // TODO: Save the actual method size.
        function saveSizesInTree(tree) {
            if (tree.children.length == 0) {
                tree.size = 1
            } else {
                tree.children.forEach(saveSizesInTree)
                tree.size = tree.children.map(child => child.size).reduce((a, b) => a + b, 0)
            }
        }

        /// Merges multiple universes containing sizes into a single tree
        /// hierarchy where each node has a `sizes` attribute containing the
        /// size in the respective tree.
        function mergeUniverses(universes) {
            function defaultSizes() {
                const sizes = {}
                for (const name of Object.keys(universes)) {
                    sizes[name] = 0
                }
                return sizes
            }

            function mergeTreeIntoChildren(tree, mergedChildren, universeName) {
                let mergedChild = mergedChildren.find((child) => child.name === tree.name)
                if (!mergedChild) {
                    mergedChild = { name: tree.name, sizes: defaultSizes(), children: [] }
                    mergedChildren.push(mergedChild)
                }
                mergedChild.sizes[universeName] = tree.size
                for (const child of tree.children) {
                    mergeTreeIntoChildren(child, mergedChild.children, universeName)
                }
            }

            const mergedChildren = []
            for (const [name, universe] of Object.entries(universes)) {
                mergeTreeIntoChildren(universe, mergedChildren, name)
            }
            const root = mergedChildren[0] // There's only the single root child.
            saveExclusiveSizesInTree(root, Object.keys(universes))
            return root
        }

        function saveExclusiveSizesInTree(tree, universeNames) {
            if (tree.children.length == 0) {
                const combination = []
                for (const name of universeNames) {
                    if (tree.sizes[name] > 0) {
                        combination.push(name)
                    }
                }

                tree.exclusiveSizes = {}
                tree.exclusiveSizes[combination] = 1 // TODO: Method size hardcoded to 1.
            } else {
                tree.children.forEach(child => saveExclusiveSizesInTree(child, universeNames))

                tree.exclusiveSizes = {}
                for (const child of tree.children) {
                    for (const combination of Object.keys(child.exclusiveSizes)) {
                        if (!tree.exclusiveSizes[combination]) tree.exclusiveSizes[combination] = 0
                        tree.exclusiveSizes[combination] += child.exclusiveSizes[combination]
                    }
                }
            }
            tree.unionedSize = Object.values(tree.exclusiveSizes).reduce((a, b) => a + b, 0)
        }

        function sortAlphabetically(tree) {
            tree.children.forEach(sortAlphabetically)
            tree.children.sort((a, b) => a.name.localeCompare(b.name))
        }

        async function loadUniverses() {
            const texts = await Promise.all([
                d3.text('used-methods-helloworld.txt'),
                d3.text('used-methods-micronaut.txt'),
            ]);
            const parsed = texts.map((text) => {
                let universe = parseUsedMethodsIntoTree(text)
                saveSizesInTree(universe)
                console.log(universe)
                return universe
            })
            let merged = mergeUniverses({
                'helloworld': parsed[0],
                'micronaut': parsed[1],
            })
            sortAlphabetically(merged)
            return merged
        }
        const universes = await loadUniverses();
        console.debug("Universes:")
        console.debug(universes)

        const canvas = document.getElementById('treeline')
        const context = canvas.getContext('2d', { alpha: false })

        // Constants that determine how the visualization looks.
        const lineWidth = 256
        const linePadding = 16 // used on the left and right of the line
        const fontSize = 16
        const textHorizontalPadding = 8
        const textVerticalPadding = 2
        const textStickyGap = 8
        const hierarchyGaps = 2 // used between boxes of the hierarchy
        const explosionThreshold = 100 // at this height, entities explode into children
        const combinations = ['helloworld', 'helloworld,micronaut', 'micronaut'];
        const colors = {
            'helloworld': '#f28e2c',
            'micronaut': '#1b9e77',
            'helloworld,micronaut': '#e6f5c9',
        }

        function drawDiagram(tree, top, pixelsPerByte, path, leftOfHierarchy) {
            const height = tree.unionedSize * pixelsPerByte

            if (top > canvas.height || top + height < 0) {
                return // Outside of the visible area.
            }

            // Show the hierarchy on the right.
            let leftOfSubHierarchy = undefined;
            if (path.length == 0) {
                leftOfSubHierarchy = leftOfHierarchy
            } else {
                const widthOfBox = drawHierarchyBox(leftOfHierarchy, top, height, path[path.length - 1])
                leftOfSubHierarchy = leftOfHierarchy + widthOfBox + hierarchyGaps
            }

            if (height >= explosionThreshold && tree.children.length > 0) {
                // There is enough room to not only show a summary of this
                // entity, but to show our children instead.
                let childOffsetFromTop = top;
                for (const child of tree.children) {
                    let childPath = path.slice();
                    childPath.push(child.name);
                    drawDiagram(child, childOffsetFromTop, pixelsPerByte, childPath, leftOfSubHierarchy)
                    childOffsetFromTop += child.unionedSize * pixelsPerByte
                }
            } else {
                // Only show a summary of this entity where colors stack
                // vertically proportional to how much code is used in each
                // universe.
                let offsetFromLeft = linePadding
                for (const combination of combinations) {
                    const size = tree.exclusiveSizes[combination] ?? 0
                    const width = lineWidth * size / tree.unionedSize
                    context.fillStyle = colors[combination]
                    // Note: Floating point calculations are never accurate, so
                    // `floor` and `ceil` are used to avoid the background
                    // peeking through the gaps.
                    context.fillRect(offsetFromLeft, Math.floor(top), width, Math.ceil(height))
                    offsetFromLeft += width
                }

            }
        }
        function drawHierarchyBox(left, top, height, text) {
            context.font = `${fontSize}px sans-serif`

            const textWidth = context.measureText(text).width
            const boxWidth = textWidth + 2 * textHorizontalPadding

            context.fillStyle = '#cccccc'
            context.fillRect(left, top, boxWidth, height - hierarchyGaps)

            const visibleStart = top.clamp(0, canvas.height)
            const visibleEnd = (top + height).clamp(0, canvas.height)

            if (height >= fontSize + 2 * textVerticalPadding) {
                const textRadius = fontSize / 2
                const textCenterY = ((visibleStart + visibleEnd) / 2)
                    .clamp(
                        top + textRadius + textVerticalPadding,
                        top + height - textRadius - textVerticalPadding,
                    )

                context.fillStyle = 'black'
                context.textBaseline = 'middle'
                context.fillText(text, left + textHorizontalPadding, textCenterY)
            }

            return boxWidth
        }

        function fitCanvasToScreen() {
            canvas.width = window.innerWidth
            canvas.height = window.innerHeight - 5
        }
        fitCanvasToScreen()

        let initialBarHeight = canvas.height - linePadding * 2
        let initialPixelsPerByte = initialBarHeight / universes.unionedSize
        let initialTop = linePadding

        function redraw() {
            fitCanvasToScreen()

            const transform = d3.event?.transform ?? { x: 0, y: 0, k: 1 }

            context.fillStyle = 'white'
            context.fillRect(0, 0, canvas.width, canvas.height)

            const top = initialTop + transform.y
            const pixelsPerByte = initialPixelsPerByte * transform.k

            const leftOfHierarchy = linePadding + lineWidth + linePadding

            drawDiagram(universes, top, pixelsPerByte, [], leftOfHierarchy)
        }
        redraw()

        d3.select(canvas).call(d3.zoom().scaleExtent([1, 10000]).on("zoom", redraw))
        window.addEventListener("resize", redraw)
    </script>
</body>
</html>

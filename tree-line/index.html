<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Tree Line</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-hierarchy@3"></script>
    <link rel="stylesheet" href="styles.css">
    <style>
        body {
            margin: 0;
        }
    </style>
</head>
<body>
    <canvas id="treeline"></canvas>
    <script type="module">
        // A function that makes sure a value is within a range. For example,
        // `2.clamp(0, 5)` returns 2 because 2 is between 0 and 5, but
        // `3.clamp(4, 6)` returns 4.
        Number.prototype.clamp = function (min, max) {
            return Math.min(Math.max(this, min), max);
        }

        /// Parses the content of a `used_methods_...` file into a tree. Ignores
        /// generated classes and their children.
        // TODO: Use the common function after Luc's PR is merged.
        function parseUsedMethodsIntoTree(text) {
            const tree = { name: '', children: [] }
            for (const row of text.split('\n')) {
                if (row == '' || row.includes('$$')) continue
                let current = tree
                for (const pathSegment of row.split(/[.$]/)) {
                    let child = current.children.find((child) => child.name === pathSegment)
                    if (!child) {
                        child = { name: pathSegment, children: [] }
                        current.children.push(child)
                    }
                    current = child
                }
            }
            return tree
        }

        /// Adds a `size` attribute in each node that corresponds to the total
        /// size of that subtree including its children. For now, we just assume
        /// that each method has a size of 1.
        // TODO: Save the actual method size.
        function saveSizesInTree(tree) {
            if (tree.children.length == 0) {
                tree.size = 1
            } else {
                tree.children.forEach(saveSizesInTree)
                tree.size = tree.children.map(child => child.size).reduce((a, b) => a + b, 0)
            }
        }

        /// Merges multiple universes containing sizes into a single tree
        /// hierarchy where each node has a `sizes` attribute containing the
        /// size in the respective tree.
        function mergeUniverses(universes) {
            function defaultSizes() {
                const sizes = {}
                for (const name of Object.keys(universes)) {
                    sizes[name] = 0
                }
                return sizes
            }

            function mergeTreeIntoChildren(tree, mergedChildren, universeName) {
                let mergedChild = mergedChildren.find((child) => child.name === tree.name)
                if (!mergedChild) {
                    mergedChild = { name: tree.name, sizes: defaultSizes(), children: [] }
                    mergedChildren.push(mergedChild)
                }
                mergedChild.sizes[universeName] = tree.size
                for (const child of tree.children) {
                    mergeTreeIntoChildren(child, mergedChild.children, universeName)
                }
            }

            const mergedChildren = []
            for (const [name, universe] of Object.entries(universes)) {
                mergeTreeIntoChildren(universe, mergedChildren, name)
            }
            const root = mergedChildren[0] // There's only the single root child.
            saveExclusiveSizesInTree(root, Object.keys(universes))
            return root
        }

        function saveExclusiveSizesInTree(tree, universeNames) {
            if (tree.children.length == 0) {
                const combination = []
                for (const name of universeNames) {
                    if (tree.sizes[name] > 0) {
                        combination.push(name)
                    }
                }

                tree.exclusiveSizes = {}
                tree.exclusiveSizes[combination] = 1 // TODO: Method size hardcoded to 1.
            } else {
                tree.children.forEach(child => saveExclusiveSizesInTree(child, universeNames))

                tree.exclusiveSizes = {}
                for (const child of tree.children) {
                    for (const combination of Object.keys(child.exclusiveSizes)) {
                        if (!tree.exclusiveSizes[combination]) tree.exclusiveSizes[combination] = 0
                        tree.exclusiveSizes[combination] += child.exclusiveSizes[combination]
                    }
                }
            }
            tree.unionedSize = Object.values(tree.exclusiveSizes).reduce((a, b) => a + b, 0)
        }

        function sortAlphabetically(tree) {
            tree.children.forEach(sortAlphabetically)
            tree.children.sort((a, b) => a.name.localeCompare(b.name))
        }

        async function loadUniverses() {
            const texts = await Promise.all([
                d3.text('used-methods-helloworld.txt'),
                d3.text('used-methods-micronaut.txt'),
            ]);
            const parsed = texts.map((text) => {
                let universe = parseUsedMethodsIntoTree(text)
                saveSizesInTree(universe)
                return universe
            })
            let merged = mergeUniverses({
                'helloworld': parsed[0],
                'micronaut': parsed[1],
            })
            sortAlphabetically(merged)
            return merged
        }
        const universes = await loadUniverses();
        console.debug("Universes:")
        console.debug(universes)

        const canvas = document.getElementById('treeline')
        const context = canvas.getContext('2d', { alpha: false })

        // Constants that determine how the visualization looks.

        const combinations = ['helloworld', 'helloworld,micronaut', 'micronaut'];
        const colors = {
            'helloworld': '#f28e2c',
            'micronaut': '#1b9e77',
        }
        const mixAlpha = 0.4
        const explosionThreshold = 100 // at this height, entities explode into children

        const lineWidth = 256
        const linePadding = 16

        const fontSize = 16
        const textHorizontalPadding = 8
        const textVerticalPadding = 2
        const hierarchyGaps = 2 // used between boxes of the hierarchy

        // Visualization code.

        let fillStyles = {}
        function buildFillStyles() {
            const lightenedColors = {}
            for (const [name, color] of Object.entries(colors)) {
                lightenedColors[name] = lightenColor(color)
            }

            fillStyles = {}
            for (const combination of combinations) {
                if (!combination.includes(',')) {
                    fillStyles[combination] = colors[combination]
                    continue
                }

                const gradientColors = combination.split(',').map(universe => lightenedColors[universe])
                const size = Math.max(canvas.width, canvas.height)
                const gradient = context.createLinearGradient(0, 0, size, size)
                const numSteps = Math.sqrt(2 * Math.pow(size, 2)) / 5

                for (let i = 0; i < numSteps; i += 1) {
                    const d = 1 / numSteps * i
                    gradient.addColorStop(d, gradientColors[i % gradientColors.length])
                    if (d + 0.001 <= 1) {
                        gradient.addColorStop(d + 0.001, gradientColors[(i + 1) % gradientColors.length])
                    }
                }

                fillStyles[combination] = gradient
            }
        }
        function lightenColor(color) {
            let r = parseInt(color.substring(1, 3), 16)
            let g = parseInt(color.substring(3, 5), 16)
            let b = parseInt(color.substring(5, 7), 16)

            const rr = Math.round(r * mixAlpha + 255 * (1 - mixAlpha))
            const gg = Math.round(g * mixAlpha + 255 * (1 - mixAlpha))
            const bb = Math.round(b * mixAlpha + 255 * (1 - mixAlpha))

            const rrr = ((rr.toString(16).length === 1) ? `0${rr.toString(16)}` : rr.toString(16))
            const ggg = ((gg.toString(16).length === 1) ? `0${gg.toString(16)}` : gg.toString(16))
            const bbb = ((bb.toString(16).length === 1) ? `0${bb.toString(16)}` : bb.toString(16))

            return `#${rrr}${ggg}${bbb}`
        }

        function drawDiagram(tree, top, pixelsPerByte, path, leftOfHierarchy) {
            const height = tree.unionedSize * pixelsPerByte

            if (top > canvas.height || top + height < 0) {
                return // Outside of the visible area.
            }

            // Show the hierarchy on the right.
            let leftOfSubHierarchy = undefined;
            if (path.length == 0) {
                leftOfSubHierarchy = leftOfHierarchy
            } else {
                let containingCombinations = Object.entries(tree.exclusiveSizes)
                    .filter(combinationAndSize => combinationAndSize[1] > 0)
                    .map(combinationAndSize => combinationAndSize[0])

                const widthOfBox = drawHierarchyBox(
                    leftOfHierarchy,
                    top,
                    height,
                    path[path.length - 1],
                    containingCombinations,
                )
                leftOfSubHierarchy = leftOfHierarchy + widthOfBox + hierarchyGaps
            }

            const shouldExplode = tree.children.length == 1
                || height >= explosionThreshold && tree.children.length > 0
            if (shouldExplode) {
                let childOffsetFromTop = top;
                for (const child of tree.children) {
                    let childPath = path.slice();
                    childPath.push(child.name);
                    drawDiagram(child, childOffsetFromTop, pixelsPerByte, childPath, leftOfSubHierarchy)
                    childOffsetFromTop += child.unionedSize * pixelsPerByte
                }
            } else {
                let offsetFromLeft = linePadding
                for (const combination of combinations) {
                    const size = tree.exclusiveSizes[combination] ?? 0
                    const width = lineWidth * size / tree.unionedSize
                    context.fillStyle = colors[combination]
                    // Note: Floating point calculations are never accurate, so
                    // `floor` and `ceil` are used to avoid the background
                    // peeking through the gaps.
                    context.fillStyle = fillStyles[combination]
                    context.fillRect(offsetFromLeft, Math.floor(top), width, Math.ceil(height))
                    
                    // context.fillRect(offsetFromLeft, Math.floor(top), width, Math.ceil(height))
                    offsetFromLeft += width
                }
            }
        }
        function drawHierarchyBox(left, top, height, text, containingCombinations) {
            context.font = `${fontSize}px sans-serif`

            const textWidth = context.measureText(text).width
            const boxWidth = textWidth + 2 * textHorizontalPadding

            context.fillStyle = containingCombinations.length == 1 ? fillStyles[containingCombinations[0]] : '#cccccc'
            context.fillRect(left, top, boxWidth, height - hierarchyGaps)

            const visibleStart = top.clamp(0, canvas.height)
            const visibleEnd = (top + height).clamp(0, canvas.height)

            if (height >= fontSize + 2 * textVerticalPadding) {
                const textRadius = fontSize / 2
                const textCenterY = ((visibleStart + visibleEnd) / 2).clamp(
                    top + textRadius + textVerticalPadding,
                    top + height - textRadius - textVerticalPadding,
                )

                context.fillStyle = 'black'
                context.textBaseline = 'middle'
                context.fillText(text, left + textHorizontalPadding, textCenterY)
            }

            return boxWidth
        }

        function fitToScreen() {
            canvas.width = window.innerWidth
            canvas.height = window.innerHeight - 5
            buildFillStyles()
        }
        fitToScreen()

        let initialBarHeight = canvas.height - linePadding * 2
        let initialPixelsPerByte = initialBarHeight / universes.unionedSize
        let initialTop = linePadding

        function redraw() {
            const transform = d3.event?.transform ?? { x: 0, y: 0, k: 1 }

            fitToScreen()

            context.fillStyle = 'white'
            context.fillRect(0, 0, canvas.width, canvas.height)

            const top = initialTop + transform.y
            const pixelsPerByte = initialPixelsPerByte * transform.k

            const leftOfHierarchy = linePadding + lineWidth + linePadding

            drawDiagram(universes, top, pixelsPerByte, [], leftOfHierarchy)
        }
        redraw()

        d3.select(canvas).call(d3.zoom().scaleExtent([1, 10000]).on('zoom', redraw))
        window.addEventListener('resize', redraw)
    </script>
</body>
</html>
